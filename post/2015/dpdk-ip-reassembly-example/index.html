<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>DPDK IP reassembly example | Keep calm and Write something</title><meta name=title content="DPDK IP reassembly example"><meta name=description content="TAILQ_HEAD(ip_pkt_list, ip_frag_pkt); /**< @internal fragments tailq */

자료 구조체
Fragment 관리용 table
struct rte_ip_frag_tbl *frag_tbl;  

locking 없이 IP reassembly를 수행할 단위(통상 core)로 한 개씩 만든다. 즉 하나의 core가 여러 rx queue를 처리하더라도 하나의 frag_tbl만 가지면 된다.
아래 rte_ip_frag_table_create()함수를 이용해서 생성한다.
struct rte_ip_frag_death_row death_row
core별로 갖는 death_row. IP reassembly를 호출한 후 해당 함수내에서 free할 mbuf를 이 리스트에 담아줌.
main loop에서 reassembly작업 후 rte_ip_frag_free_death_row()함수를 호출해 reassembly에 실패한 mbuf를 free함
IP_MAX_FRAG_NUM defines the maximum fragments of one reassembly. Defined same as RTE_LIBRTE_IP_FRAG_MAX_FRAG aka 4."><meta name=keywords content="DPDK,R210,"><meta property="og:url" content="https://cychong47.github.io/post/2015/dpdk-ip-reassembly-example/"><meta property="og:site_name" content="Keep calm and Write something"><meta property="og:title" content="DPDK IP reassembly example"><meta property="og:description" content="TAILQ_HEAD(ip_pkt_list, ip_frag_pkt); /**< @internal fragments tailq */ 자료 구조체 Fragment 관리용 table struct rte_ip_frag_tbl *frag_tbl; locking 없이 IP reassembly를 수행할 단위(통상 core)로 한 개씩 만든다. 즉 하나의 core가 여러 rx queue를 처리하더라도 하나의 frag_tbl만 가지면 된다.
아래 rte_ip_frag_table_create()함수를 이용해서 생성한다.
struct rte_ip_frag_death_row death_row core별로 갖는 death_row. IP reassembly를 호출한 후 해당 함수내에서 free할 mbuf를 이 리스트에 담아줌.
main loop에서 reassembly작업 후 rte_ip_frag_free_death_row()함수를 호출해 reassembly에 실패한 mbuf를 free함
IP_MAX_FRAG_NUM defines the maximum fragments of one reassembly. Defined same as RTE_LIBRTE_IP_FRAG_MAX_FRAG aka 4."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2015-11-17T13:49:57+09:00"><meta property="article:modified_time" content="2018-04-01T02:38:40+00:00"><meta property="article:tag" content="DPDK"><meta property="article:tag" content="R210"><meta name=twitter:card content="summary"><meta name=twitter:title content="DPDK IP reassembly example"><meta name=twitter:description content="TAILQ_HEAD(ip_pkt_list, ip_frag_pkt); /**< @internal fragments tailq */ 자료 구조체 Fragment 관리용 table struct rte_ip_frag_tbl *frag_tbl; locking 없이 IP reassembly를 수행할 단위(통상 core)로 한 개씩 만든다. 즉 하나의 core가 여러 rx queue를 처리하더라도 하나의 frag_tbl만 가지면 된다.
아래 rte_ip_frag_table_create()함수를 이용해서 생성한다.
struct rte_ip_frag_death_row death_row core별로 갖는 death_row. IP reassembly를 호출한 후 해당 함수내에서 free할 mbuf를 이 리스트에 담아줌.
main loop에서 reassembly작업 후 rte_ip_frag_free_death_row()함수를 호출해 reassembly에 실패한 mbuf를 free함
IP_MAX_FRAG_NUM defines the maximum fragments of one reassembly. Defined same as RTE_LIBRTE_IP_FRAG_MAX_FRAG aka 4."><meta itemprop=name content="DPDK IP reassembly example"><meta itemprop=description content="TAILQ_HEAD(ip_pkt_list, ip_frag_pkt); /**< @internal fragments tailq */ 자료 구조체 Fragment 관리용 table struct rte_ip_frag_tbl *frag_tbl; locking 없이 IP reassembly를 수행할 단위(통상 core)로 한 개씩 만든다. 즉 하나의 core가 여러 rx queue를 처리하더라도 하나의 frag_tbl만 가지면 된다.
아래 rte_ip_frag_table_create()함수를 이용해서 생성한다.
struct rte_ip_frag_death_row death_row core별로 갖는 death_row. IP reassembly를 호출한 후 해당 함수내에서 free할 mbuf를 이 리스트에 담아줌.
main loop에서 reassembly작업 후 rte_ip_frag_free_death_row()함수를 호출해 reassembly에 실패한 mbuf를 free함
IP_MAX_FRAG_NUM defines the maximum fragments of one reassembly. Defined same as RTE_LIBRTE_IP_FRAG_MAX_FRAG aka 4."><meta itemprop=datePublished content="2015-11-17T13:49:57+09:00"><meta itemprop=dateModified content="2018-04-01T02:38:40+00:00"><meta itemprop=wordCount content="603"><meta itemprop=keywords content="DPDK,R210"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style></head><body><header><a href=/ class=title><h2>Keep calm and Write something</h2></a><nav><a href=/post/>Post</a>
<a href=/page/>Page</a>
<a href=/series/>Series</a>
<a href=/tags/>Tag</a>
<a href=/archive/>Archive</a>
<a href=/search/>Search</a></nav></header><main><content><pre><code>TAILQ_HEAD(ip_pkt_list, ip_frag_pkt); /**&lt; @internal fragments tailq */
</code></pre><h3 id=자료-구조체>자료 구조체</h3><h5 id=fragment-관리용-table>Fragment 관리용 table</h5><pre><code>struct rte_ip_frag_tbl *frag_tbl;  
</code></pre><p>locking 없이 IP reassembly를 수행할 단위(통상 core)로 한 개씩 만든다. 즉 하나의 core가 여러 rx queue를 처리하더라도 하나의 <code>frag_tbl</code>만 가지면 된다.<br>아래 <code>rte_ip_frag_table_create()</code>함수를 이용해서 생성한다.</p><h5 id=struct-rte_ip_frag_death_row-death_row><code>struct rte_ip_frag_death_row death_row</code></h5><p>core별로 갖는 death_row. IP reassembly를 호출한 후 해당 함수내에서 free할 mbuf를 이 리스트에 담아줌.<br>main loop에서 reassembly작업 후 <code>rte_ip_frag_free_death_row()</code>함수를 호출해 reassembly에 실패한 mbuf를 free함</p><p><code>IP_MAX_FRAG_NUM</code> defines the maximum fragments of one reassembly. Defined same as <code>RTE_LIBRTE_IP_FRAG_MAX_FRAG</code> aka 4.</p><h3 id=주요-함수>주요 함수</h3><h5 id=rte_ipv4_frag_reassemble_packet><code>rte_ipv4_frag_reassemble_packet</code></h5><p>실제 reassembly를 수행하는 함수.</p><ul><li>첫번째 인자는 ip fragment들이 저장된 ip_frag_tbl의 pointer</li><li>두번째 인자는 death_row를 저장할 pointer.</li><li>세번째 인자는 현재 수신한 mbuf의 pointer</li><li>네번째 인자는 패킷이 수신한 timestamp. <code>rdtsc_tsc()</code>의 결과</li><li>다섯번째 인자는 pointer to ip header(<code>struct ipv4_hdr *</code>)</li></ul><h5 id=rte_ipv6_frag_reassemble_packet><code>rte_ipv6_frag_reassemble_packet()</code></h5><p>IPv6용 reassembly 함수. 함수의 인자는 <code>rte_ipv4_frag_reassemble_packet()</code>와 유사하지만, 마지막에 <code>struct ipv6_extension_fragment *</code>가 추가된다.</p><h5 id=rte_ipv4_frag_pkt_is_fragmented><code>rte_ipv4_frag_pkt_is_fragmented()</code></h5><p>Return 1 if packet is fragmented.</p><h5 id=rte_ipv6_frag_get_ipv6_fragment_header><code>rte_ipv6_frag_get_ipv6_fragment_header()</code></h5><p>IPv6 경우 위 함수를 통해 frag_hdr 위치를 돌려받는다. <code>struct ipv6_extension_fragment *</code>
단순히 IPv6 base header 바로 뒷 헤더만 확인함.(표준 확인 필요)</p><h5 id=rte_ip_frag_table_create><code>rte_ip_frag_table_create()</code></h5><pre><code>struct rte_ip_frag_tbl * rte_ip_frag_table_create(
       uint32_t bucket_num, 
       uint32_t bucket_entries,  
       uint32_t max_entries, 
       uint64_t max_cycles,
       int socket_id);                                                       
</code></pre><ul><li><code>bucket_num</code> : # of bucket(Flow 개수). Should be power of 2</li><li><code>bucket_entries</code> : bucket당 개수(hash associativity)</li><li><code>max_entries</code> : # of flows to be stored in table. less or equal to <code>max_flow_num * bucket_entries</code></li><li><code>max_cycles</code> : Maximum TTL in cycles for each fragmented packet. <code>frag_cycles = (rte_get_tsc_hz() + MS_PER_S - 1) / MS_PER_S * max_flow_ttl;</code> 예. 1ms에 해당하는 TSC value</li><li>socket : 메모리를 할당할 socket ID. core와 함께 있는 socket 정보를 넣으면 됨.</li></ul><p>defined in <code>lib/librte_ip_frag/rte_ip_frag.h</code></p><pre><code>/** fragmentation table */
struct rte_ip_frag_tbl {
    uint64_t             max_cycles;      /**&lt; ttl for table entries. */
    uint32_t             entry_mask;      /**&lt; hash value mask. */
    uint32_t             max_entries;     /**&lt; max entries allowed. */
    uint32_t             use_entries;     /**&lt; entries in use. */
    uint32_t             bucket_entries;  /**&lt; hash assocaitivity. */
    uint32_t             nb_entries;      /**&lt; total size of the table. */
    uint32_t             nb_buckets;      /**&lt; num of associativity lines. */
    struct ip_frag_pkt *last;         /**&lt; last used entry. */
    struct ip_pkt_list lru;           /**&lt; LRU list for table entries. */
    struct ip_frag_tbl_stat stat;     /**&lt; statistics counters. */
    struct ip_frag_pkt pkt[0];        /**&lt; hash table. */
};
</code></pre><h5 id=rte_ip_frag_free_death_row><code>rte_ip_frag_free_death_row()</code></h5><p>prefetch가 왜 필요한 지??(FIXME)</p><pre><code>/*
 * Free mbufs on a given death row.
 *
 * @param dr
 *   Death row to free mbufs in.
 * @param prefetch
 *   How many buffers to prefetch before freeing.
 */
void rte_ip_frag_free_death_row(struct rte_ip_frag_death_row *dr,
        uint32_t prefetch);
</code></pre><p>예) if death_row has 10 entries and prefetch is 5</p><pre><code>&lt;&lt; Step 1 &gt;&gt;
prefetch 0
prefetch 1
prefetch 2
prefetch 3
prefetch 4

&lt;&lt; Step 2 &gt;&gt;
prefetch 5
free 0
prefetch 6
free 1
prefetch 7
free 2
prefetch 8
free 3
prefetch 9
free 4

&lt;&lt; Step 3 &gt;&gt;
free 5
free 6
free 7
free 8
free 9
</code></pre><h4 id=동작>동작</h4><p><code>rte_ipv4_frag_reassemble_packet()</code> 혹은 <code>rte_ipv6_frag_reassemble_packet()</code>는 reassembly에 성공한 경우 해당 <code>struct mbuf *</code>를 리터한다. 그러므로 해당 mbuf를 다음 작업에 처리하면 됨.</p><pre><code>struct rte_ip_frag_death_row *dr = &amp;qconf-&gt;death_row;
if (rte_ipv4_frag_pkt_is_fragmented(ip_hdr)) {
    struct rte_mbuf *mo;

    tbl = rxq-&gt;frag_tbl;
    dr = &amp;qconf-&gt;death_row;

    /* prepare mbuf: setup l2_len/l3_len. */
    m-&gt;l2_len = sizeof(*eth_hdr);
    m-&gt;l3_len = sizeof(*ip_hdr);

    /* process this fragment. */
    mo = rte_ipv4_frag_reassemble_packet(tbl, dr, m, tms, ip_hdr);
    if (mo == NULL)
        /* no packet to send out. */
        return;
    else
        /* mo를 이용해서 post processing */
} 
rte_ip_frag_free_death_row(dr, PREFETCH_OFFSET);  
</code></pre><p>IPv6 경우</p><pre><code>frag_hdr = rte_ipv6_frag_get_ipv6_fragment_header(ip_hdr);

if (frag_hdr != NULL) {
    struct rte_mbuf *mo;

    tbl = rxq-&gt;frag_tbl;
    dr  = &amp;qconf-&gt;death_row;

    /* prepare mbuf: setup l2_len/l3_len. */
    m-&gt;l2_len = sizeof(*eth_hdr);
    m-&gt;l3_len = sizeof(*ip_hdr) + sizeof(*frag_hdr);

    mo = rte_ipv6_frag_reassemble_packet(tbl, dr, m, tms, ip_hdr, frag_hdr);
    if (mo == NULL)
        return;

    if (mo != m) {
        m = mo;
        eth_hdr = rte_pktmbuf_mtod(m, struct ether_hdr *);
        ip_hdr = (struct ipv6_hdr *)(eth_hdr + 1);
    }
}

rte_ip_frag_free_death_row(dr, PREFETCH_OFFSET);  
</code></pre></content><p><a href=https://cychong47.github.io/tags/dpdk/>#DPDK</a>
<a href=https://cychong47.github.io/tags/r210/>#R210</a></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>