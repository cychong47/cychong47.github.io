<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>DPDK Coding style | Keep calm and Write something</title><meta name=title content="DPDK Coding style"><meta name=description content="출처 : DPDK mailing list
Coding Style
Description
This document specifies the preferred style for source files in the DPDK
source tree. It is based on the Linux Kernel coding guidelines and the
FreeBSD 7.2 Kernel Developer&rsquo;s Manual (see man style(9)), but was
heavily modified for the needs of the DPDK.
General Guidelines
The rules and guidelines given in this document cannot cover every
situation, so the following general guidelines should be used as a
fallback:"><meta name=keywords content="DPDK,Coding Style,C,"><meta property="og:url" content="https://cychong47.github.io/post/2015/dpdk-coding-style/"><meta property="og:site_name" content="Keep calm and Write something"><meta property="og:title" content="DPDK Coding style"><meta property="og:description" content="출처 : DPDK mailing list
Coding Style Description This document specifies the preferred style for source files in the DPDK source tree. It is based on the Linux Kernel coding guidelines and the FreeBSD 7.2 Kernel Developer’s Manual (see man style(9)), but was heavily modified for the needs of the DPDK.
General Guidelines The rules and guidelines given in this document cannot cover every situation, so the following general guidelines should be used as a fallback:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2015-05-21T14:51:37+09:00"><meta property="article:modified_time" content="2018-04-01T02:38:40+00:00"><meta property="article:tag" content="DPDK"><meta property="article:tag" content="Coding Style"><meta property="article:tag" content="C"><meta name=twitter:card content="summary"><meta name=twitter:title content="DPDK Coding style"><meta name=twitter:description content="출처 : DPDK mailing list
Coding Style Description This document specifies the preferred style for source files in the DPDK source tree. It is based on the Linux Kernel coding guidelines and the FreeBSD 7.2 Kernel Developer’s Manual (see man style(9)), but was heavily modified for the needs of the DPDK.
General Guidelines The rules and guidelines given in this document cannot cover every situation, so the following general guidelines should be used as a fallback:"><meta itemprop=name content="DPDK Coding style"><meta itemprop=description content="출처 : DPDK mailing list
Coding Style Description This document specifies the preferred style for source files in the DPDK source tree. It is based on the Linux Kernel coding guidelines and the FreeBSD 7.2 Kernel Developer’s Manual (see man style(9)), but was heavily modified for the needs of the DPDK.
General Guidelines The rules and guidelines given in this document cannot cover every situation, so the following general guidelines should be used as a fallback:"><meta itemprop=datePublished content="2015-05-21T14:51:37+09:00"><meta itemprop=dateModified content="2018-04-01T02:38:40+00:00"><meta itemprop=wordCount content="4383"><meta itemprop=keywords content="DPDK,Coding Style,C"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style></head><body><header><a href=/ class=title><h2>Keep calm and Write something</h2></a><nav><a href=/post/>Post</a>
<a href=/page/>Page</a>
<a href=/series/>Series</a>
<a href=/tags/>Tag</a>
<a href=/archive/>Archive</a>
<a href=/search/>Search</a></nav></header><main><content><p>출처 : <a href=http://dpdk.org/ml/archives/dev/2015-May/017666.html>DPDK mailing list</a></p><h1 id=coding-style>Coding Style</h1><h2 id=description>Description</h2><p>This document specifies the preferred style for source files in the DPDK
source tree. It is based on the Linux Kernel coding guidelines and the
FreeBSD 7.2 Kernel Developer&rsquo;s Manual (see man style(9)), but was
heavily modified for the needs of the DPDK.</p><h2 id=general-guidelines>General Guidelines</h2><p>The rules and guidelines given in this document cannot cover every
situation, so the following general guidelines should be used as a
fallback:</p><ul><li>The code style should be consistent within each individual file.</li><li>In the case of creating new files, the style should be consistent
within each file in a given directory or module.</li><li>The primary reason for coding standards is to increase code
readability and comprehensibility, therefore always use whatever
option will make the code easiest to read.</li></ul><p>Line length is recommended to be not more than 80 characters, including
comments. [Tab stop size should be assumed to be 8-characters wide].</p><blockquote><p><strong>note</strong></p><p>The above is recommendation, and not a hard limit. However, it is
expected that the recommendations should be followed in all but the
rarest situations.</p></blockquote><h2 id=c-comment-style>C Comment Style</h2><h3 id=usual-comments>Usual Comments</h3><p>These comments should be used in normal cases. To document a public API,
a doxygen-like format must be used: refer to Doxygen Documentation.</p><pre tabindex=0><code>/*
 * VERY important single-line comments look like this.
 */

/* Most single-line comments look like this. */

/*
 * Multi-line comments look like this.  Make them real sentences. Fill
 * them so they look like real paragraphs.
 */
</code></pre><h3 id=license-header>License Header</h3><p>Each file should begin with a special comment containing the appropriate
copyright and license for the file. Generally this is the BSD License,
except for code for Linux Kernel modules. After any copyright header, a
blank line should be left before any other contents, e.g. include
statements in a C file.</p><h2 id=c-preprocessor-directives>C Preprocessor Directives</h2><h3 id=header-includes>Header Includes</h3><p>In DPDK sources, the include files should be ordered as following:</p><ol><li>libc includes (system includes first)</li><li>DPDK EAL includes</li><li>DPDK misc libraries includes</li><li>application-specific includes</li></ol><p>Include files from the local application directory are included using
quotes, while includes from other paths are included using angle
brackets: &ldquo;&lt;>&rdquo;.</p><p>Example:</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;rte_eal.h&gt;

#include &lt;rte_ring.h&gt;
#include &lt;rte_mempool.h&gt;

#include &#34;application.h&#34;
</code></pre><h3 id=header-file-guards>Header File Guards</h3><p>Headers should be protected against multiple inclusion with the usual:</p><pre tabindex=0><code>#ifndef _FILE_H_
#define _FILE_H_

/* Code */

#endif /* _FILE_H_ */
</code></pre><h3 id=macros>Macros</h3><p>Do not <code>#define</code> or declare names except with the standard DPDK prefix:
<code>RTE_</code>. This is to ensure there are no collisions with definitions in
the application itself.</p><p>The names of &ldquo;unsafe&rdquo; macros (ones that have side effects), and the
names of macros for manifest constants, are all in uppercase.</p><p>The expansions of expression-like macros are either a single token or
have outer parentheses. If a macro is an inline expansion of a function,
the function name is all in lowercase and the macro has the same name
all in uppercase. If the macro encapsulates a compound statement,
enclose it in a do-while loop, so that it can be used safely in if
statements. Any final statement-terminating semicolon should be supplied
by the macro invocation rather than the macro, to make parsing easier
for pretty-printers and editors.</p><p>For example:</p><pre tabindex=0><code>#define MACRO(x, y) do {                                        \
        variable = (x) + (y);                                   \
        (y) += 2;                                               \
} while(0)
</code></pre><blockquote><p><strong>note</strong></p><p>Wherever possible, enums and inline functions should be preferred to
macros, since they provide additional degrees of type-safety and can
allow compilers to emit extra warnings about unsafe code.</p></blockquote><h3 id=conditional-compilation>Conditional Compilation</h3><p>When code is conditionally compiled using <code>#ifdef</code> or <code>#if</code>, a comment
may be added following the matching <code>#endif</code> or <code>#else</code> to permit the
reader to easily discern where conditionally compiled code regions end.
This comment should be used only for (subjectively) long regions,
regions greater than 20 lines, or where a series of nested <code>#ifdef</code>&rsquo;s
may be confusing to the reader. Exceptions may be made for cases where
code is conditionally not compiled for the purposes of lint(1), or other
tools, even though the uncompiled region may be small. The comment
should be separated from the <code>#endif</code> or <code>#else</code> by a single space. For
short conditionally compiled regions, a closing comment should not be
used. The comment for <code>#endif</code> should match the expression used in the
corresponding <code>#if</code> or <code>#ifdef</code>. The comment for <code>#else</code> and <code>#elif</code>
should match the inverse of the expression(s) used in the preceding
<code>#if</code> and/or <code>#elif</code> statements. In the comments, the subexpression
<code>defined(FOO)</code> is abbreviated as &ldquo;FOO&rdquo;. For the purposes of comments,
<code>#ifndef FOO</code> is treated as <code>#if !defined(FOO)</code>.</p><pre tabindex=0><code>#ifdef KTRACE
#include &lt;sys/ktrace.h&gt;
#endif

#ifdef COMPAT_43
/* A large region here, or other conditional code. */
#else /* !COMPAT_43 */
/* Or here. */
#endif /* COMPAT_43 */

#ifndef COMPAT_43
/* Yet another large region here, or other conditional code. */
#else /* COMPAT_43 */
/* Or here. */
#endif /* !COMPAT_43 */
</code></pre><blockquote><p><strong>note</strong></p><p>Conditional compilation should be used only when absolutely necessary,
as it increases the number of target binaries that need to be built
and tested.</p></blockquote><h2 id=c-types>C Types</h2><h3 id=integers>Integers</h3><p>For fixed/minimum-size integer values, the project uses the form
uintXX_t (from stdint.h) instead of older BSD-style integer identifiers
of the form u_intXX_t.</p><h3 id=enumerations>Enumerations</h3><ul><li>Enumeration values are all uppercase.</li></ul><pre tabindex=0><code>enum enumtype { ONE, TWO } et;
</code></pre><ul><li>Enum types should be used in preference to macros #defining a set
of (sequential) values.</li><li>Enum types should be prefixed with <code>rte_</code> and the elements by a
suitable prefix [generally starting <code>RTE_&lt;enum>_</code> - where &lt;enum>
is a shortname for the enum type] to avoid namespace collisions.</li></ul><h3 id=bitfields>Bitfields</h3><p>The developer should group bitfields that are included in the same
integer, as follows:</p><pre tabindex=0><code>struct grehdr {
  uint16_t rec:3,
      srr:1,
      seq:1,
      key:1,
      routing:1,
      csum:1,
      version:3,
      reserved:4,
      ack:1;
/* ... */
}
</code></pre><h3 id=variable-declarations>Variable Declarations</h3><p>In declarations, do not put any whitespace between asterisks and
adjacent tokens, except for tokens that are identifiers related to
types. (These identifiers are the names of basic types, type qualifiers,
and typedef-names other than the one being declared.) Separate these
identifiers from asterisks using a single space.</p><p>For example:</p><pre tabindex=0><code>int *x;         /* no space after asterisk */
int * const x;  /* space after asterisk when using a type qualifier */
</code></pre><ul><li>All externally-visible variables should have an <code>rte_</code> prefix in the
name to avoid namespace collisions.</li><li>Do not use uppercase letters - either in the form of ALL_UPPERCASE,
or CamelCase - in variable names. Lower-case letters and underscores
only.</li></ul><h3 id=structure-declarations>Structure Declarations</h3><ul><li>In general, when declaring variables in new structures, declare them
sorted by use, then by size (largest to smallest), and then in
alphabetical order. Sorting by use means that commonly used
variables are used together and that the structure layout makes
logical sense. Ordering by size then ensures that as little padding
is added to the structure as possible.</li><li>For existing structures, additions to structures should be added to
the end so for backward compatibility reasons.</li><li>Each structure element gets its own line.</li><li>Try to make the structure readable by aligning the member names
using spaces as shown below.</li><li>Names following extremely long types, which therefore cannot be
easily aligned with the rest, should be separated by a single space.</li></ul><pre tabindex=0><code>struct foo {
        struct foo      *next;          /* List of active foo. */
        struct mumble   amumble;        /* Comment for mumble. */
        int             bar;            /* Try to align the comments. */
        struct verylongtypename *baz;   /* Won&#39;t fit with other members */
};
</code></pre><ul><li>Major structures should be declared at the top of the file in which
they are used, or in separate header files if they are used in
multiple source files.</li><li>Use of the structures should be by separate variable declarations
and those declarations must be extern if they are declared in a
header file.</li><li>Externally visible structure definitions should have the structure
name prefixed by <code>rte_</code> to avoid namespace collisions.</li></ul><h3 id=queues>Queues</h3><p>Use queue(3) macros rather than rolling your own lists, whenever
possible. Thus, the previous example would be better written:</p><pre tabindex=0><code>#include &lt;sys/queue.h&gt;

struct foo {
        LIST_ENTRY(foo) link;      /* Use queue macros for foo lists. */
        struct mumble   amumble;   /* Comment for mumble. */
        int             bar;       /* Try to align the comments. */
        struct verylongtypename *baz;   /* Won&#39;t fit with other members */
};
LIST_HEAD(, foo) foohead;          /* Head of global foo list. */
</code></pre><p>DPDK also provides an optimized way to store elements in lockless rings.
This should be used in all data-path code, when there are several
consumer and/or producers to avoid locking for concurrent access.</p><h3 id=typedefs>Typedefs</h3><p>Avoid using typedefs for structure types.</p><p>For example, use:</p><pre tabindex=0><code>struct my_struct_type {
/* ... */
};

struct my_struct_type my_var;
</code></pre><p>rather than:</p><pre tabindex=0><code>typedef struct my_struct_type {
/* ... */
} my_struct_type;

my_struct_type my_var
</code></pre><p>Typedefs are problematic because they do not properly hide their
underlying type; for example, you need to know if the typedef is the
structure itself, as shown above, or a pointer to the structure. In
addition, they must be declared exactly once, whereas an incomplete
structure type can be mentioned as many times as necessary. Typedefs are
difficult to use in stand-alone header files. The header that defines
the typedef must be included before the header that uses it, or by the
header that uses it (which causes namespace pollution), or there must be
a back-door mechanism for obtaining the typedef.</p><p>Note that #defines used instead of typedefs also are problematic (since
they do not propagate the pointer type correctly due to direct text
replacement). For example, <code>#define pint int *</code> does not work as
expected, while <code>typedef int *pint</code> does work. As stated when discussing
macros, typedefs should be preferred to macros in cases like this.</p><p>When convention requires a typedef; make its name match the struct tag.
Avoid typedefs ending in <code>_t</code>, except as specified in Standard C or by
POSIX.</p><blockquote><p><strong>note</strong></p><p>It is recommended to use typedefs to define function pointer types,
for reasons of code readability. This is especially true when the
function type is used as a parameter to another function.</p></blockquote><p>For example:</p><pre tabindex=0><code>/**
 * Definition of a remote launch function.
 */
typedef int (lcore_function_t)(void *);

/* launch a function of lcore_function_t type */
int rte_eal_remote_launch(lcore_function_t *f, void *arg, unsigned slave_id);
</code></pre><h2 id=c-indentation>C Indentation</h2><h3 id=general>General</h3><ul><li>Indentation is a hard tab, that is, a tab character, not a sequence
of spaces,</li></ul><blockquote><p><strong>note</strong></p><p>Global whitespace rule in DPDK, use tabs for indentation, spaces for
alignment.</p></blockquote><ul><li>Do not put any spaces before a tab for indentation.</li><li>If you have to wrap a long statement, put the operator at the end of
the line, and indent again.</li><li>For control statements (if, while, etc.), continuation it is
recommended that the next line be indented by two tabs, rather than
one, to prevent confusion as to whether the second line of the
control statement forms part of the statement body or not.
Alternatively, the line continuation may use additional spaces to
line up to an appropriately point on the preceding line, for
example, to align to an opening brace.</li></ul><blockquote><p><strong>note</strong></p><p>As with all style guidelines, code should match style already in use
in an existing file.</p></blockquote><pre tabindex=0><code>while (really_long_variable_name_1 == really_long_variable_name_2 &amp;&amp;
    var3 == var4){  /* confusing to read as */
    x = y + z;      /* control stmt body lines up with second line of */
    a = b + c;      /* control statement itself if single indent used */
}

if (really_long_variable_name_1 == really_long_variable_name_2 &amp;&amp;
        var3 == var4){  /* two tabs used */
    x = y + z;          /* statement body no longer lines up */
    a = b + c;
}

z = a + really + long + statement + that + needs +
        two + lines + gets + indented + on + the +
        second + and + subsequent + lines;
</code></pre><ul><li>Do not add whitespace at the end of a line.</li><li>Do not add whitespace or a blank line at the end of a file.</li></ul><h3 id=control-statements-and-loops>Control Statements and Loops</h3><ul><li>Include a space after keywords (if, while, for, return, switch).</li><li>Do not use braces (<code>{</code> and <code>}</code>) for control statements with zero or
just a single statement, unless that statement is more than a single
line in which case the braces are permitted.</li></ul><pre tabindex=0><code>for (p = buf; *p != &#39;\0&#39;; ++p)
        ;       /* nothing */
for (;;)
        stmt;
for (;;) {
        z = a + really + long + statement + that + needs +
                two + lines + gets + indented + on + the +
                second + and + subsequent + lines;
}
for (;;) {
        if (cond)
                stmt;
}
if (val != NULL)
        val = realloc(val, newsize);
</code></pre><ul><li>Parts of a for loop may be left empty.</li></ul><pre tabindex=0><code>for (; cnt &lt; 15; cnt++) {
        stmt1;
        stmt2;
}
</code></pre><ul><li>Closing and opening braces go on the same line as the else keyword.
Braces that are not necessary should be left out.</li></ul><pre tabindex=0><code>if (test)
        stmt;
else if (bar) {
        stmt;
        stmt;
} else
        stmt;
</code></pre><h3 id=function-calls>Function Calls</h3><ul><li>Do not use spaces after function names.</li><li>Commas should have a space after them.</li><li>No spaces after <code>(</code> or <code>[</code> or preceding the <code>]</code> or <code>)</code> characters.</li></ul><pre tabindex=0><code>error = function(a1, a2);
if (error != 0)
    exit(error);
</code></pre><h3 id=operators>Operators</h3><ul><li>Unary operators do not require spaces, binary operators do.</li><li>Do not use parentheses unless they are required for precedence or
unless the statement is confusing without them. However, remember
that other people may be more easily confused than you.</li></ul><h3 id=exit>Exit</h3><p>Exits should be 0 on success, or 1 on failure.</p><pre tabindex=0><code>exit(0);        /*
                 * Avoid obvious comments such as
                 * &#34;Exit 0 on success.&#34;
                 */
</code></pre><blockquote><p>}</p></blockquote><h3 id=local-variables>Local Variables</h3><ul><li>Variables should be declared at the start of a block of code rather
than in the middle. The exception to this is when the variable is
<code>const</code> in which case the declaration must be at the point of first
use/assignment.</li><li>When declaring variables in functions, multiple variables per line
are OK. However, if multiple declarations would cause the line to
exceed a reasonable line length, begin a new set of declarations on
the next line rather than using a line continuation.</li><li>Be careful to not obfuscate the code by initializing variables in
the declarations, only the last variable on a line should be
initialized. If multiple variables are to be initialised when
defined, put one per line.</li><li>Do not use function calls in initializers, except for <code>const</code>
variables.</li></ul><pre tabindex=0><code>int i = 0, j = 0, k = 0;  /* bad, too many initializer */

char a = 0;        /* OK, one variable per line with initializer */
char b = 0;

float x, y = 0.0;  /* OK, only last variable has initializer */
</code></pre><h3 id=casts-and-sizeof>Casts and sizeof</h3><ul><li>Casts and sizeof statements are not followed by a space.</li><li>Always write sizeof statements with parenthesis. The redundant
parenthesis rules do not apply to sizeof(var) instances.</li></ul><h2 id=c-function-definition-declaration-and-use>C Function Definition, Declaration and Use</h2><h3 id=prototypes>Prototypes</h3><ul><li>It is recommended (and generally required by the compiler) that all
non-static functions are prototyped somewhere.</li><li>Functions local to one source module should be declared static, and
should not be prototyped unless absolutely necessary.</li><li>Functions used from other parts of code (external API) must be
prototyped in the relevant include file.</li><li>Function prototypes should be listed in a logical order, preferably
alphabetical unless there is a compelling reason to use a different
ordering.</li><li>Functions that are used locally in more than one module go into a
separate header file, for example, &ldquo;extern.h&rdquo;.</li><li>Do not use the <code>__P</code> macro.</li><li>Functions that are part of an external API should be documented
using Doxygen-like comments above declarations. See the Doxgen
documentation topic for details.</li><li>Functions that are part of the external API must have an <code>rte_</code>
prefix on the function name.</li><li>Do not use uppercase letters - either in the form of ALL_UPPERCASE,
or CamelCase - in function names. Lower-case letters and underscores
only.</li><li>When prototyping functions, associate names with parameter types,
for example:</li></ul><pre tabindex=0><code>void function1(int fd); /* good */
void function2(int);    /* bad */
</code></pre><ul><li>Short function prototypes should be contained on a single line.
Longer prototypes, e.g. those with many parameters, can be split
across multiple lines. The second and subsequent lines should be
further indented as for line statement continuations as described in
the previous section.</li></ul><pre tabindex=0><code>static char *function1(int _arg, const char *_arg2,
       struct foo *_arg3,
       struct bar *_arg4,
       struct baz *_arg5);
static void usage(void);
</code></pre><blockquote><p><strong>note</strong></p><p>Unlike function definitions, the function prototypes do not need to
place the function return type on a separate line.</p></blockquote><h3 id=definitions>Definitions</h3><ul><li>The function type should be on a line by itself preceding the
function.</li><li>The opening brace of the function body should be on a line by
itself.</li></ul><pre tabindex=0><code>static char *
function(int a1, int a2, float fl, int a4)
{
</code></pre><ul><li>Do not declare functions inside other functions. ANSI C states that
such declarations have file scope regardless of the nesting of the
declaration. Hiding file declarations in what appears to be a local
scope is undesirable and will elicit complaints from a good
compiler.</li><li>Old-style (K&amp;R) function declaration should not be used, use ANSI
function declarations instead as shown below.</li><li>Long argument lists should be wrapped as described above in the
function prototypes section.</li></ul><pre tabindex=0><code>/*
 * All major routines should have a comment briefly describing what
 * they do. The comment before the &#34;main&#34; routine should describe
 * what the program does.
 */
int
main(int argc, char *argv[])
{
        char *ep;
        long num;
        int ch;
</code></pre><h2 id=c-statement-style-and-conventions>C Statement Style and Conventions</h2><h3 id=null-pointers>NULL Pointers</h3><ul><li>NULL is the preferred null pointer constant. Use NULL instead of
<code>(type *)0</code> or <code>(type *)NULL</code>, except where the compiler does not
know the destination type e.g. for variadic args to a function.</li><li>Test pointers against NULL, for example, use:</li></ul><pre tabindex=0><code>if (p == NULL) /* Good, compare pointer to NULL */

if (!p) /* Bad, using ! on pointer */
</code></pre><ul><li>Do not use ! for tests unless it is a boolean, for example, use:</li></ul><pre tabindex=0><code>if (*p == &#39;\0&#39;) /* check character against (char)0 */
</code></pre><h3 id=return-value>Return Value</h3><ul><li>Functions which create objects, or allocate memory, should return
pointer types, and NULL on error. The error type should be indicated
may setting the variable <code>rte_errno</code> appropriately.</li><li>Functions which work on bursts of packets, such as RX-like or
TX-like functions, should return the number of packets handled.</li><li>Other functions returning int should generally behave like system
calls: returning 0 on success and -1 on error, setting <code>rte_errno</code>
to indicate the specific type of error.</li><li>Where already standard in a given library, the alternative error
approach may be used where the negative value is not -1 but is
instead <code>-errno</code> if relevant, for example, <code>-EINVAL</code>. Note, however,
to allow consistency across functions returning integer or pointer
types, the previous approach is preferred for any new libraries.</li><li>For functions where no error is possible, the function type should
be <code>void</code> not <code>int</code>.</li><li>Routines returning <code>void *</code> should not have their return values cast
to any pointer type. (Typecasting can prevent the compiler from
warning about missing prototypes as any implicit definition of a
function returns int - which, unlike <code>void *</code> needs a typecast to
assign to a pointer variable.)</li></ul><blockquote><p><strong>note</strong></p><p>The above rule about not typecasting <code>void *</code> applies to malloc, as
well as to DPDK functions.</p></blockquote><ul><li>Values in return statements should not be enclosed in parentheses.</li></ul><h3 id=logging-and-errors>Logging and Errors</h3><p>In the DPDK environment, use the logging interface provided:</p><pre tabindex=0><code>#define RTE_LOGTYPE_TESTAPP1 RTE_LOGTYPE_USER1
#define RTE_LOGTYPE_TESTAPP2 RTE_LOGTYPE_USER2

/* enable these logs type */
rte_set_log_type(RTE_LOGTYPE_TESTAPP1, 1);
rte_set_log_type(RTE_LOGTYPE_TESTAPP2, 1);

/* log in debug level */
rte_set_log_level(RTE_LOG_DEBUG);
RTE_LOG(DEBUG, TESTAPP1, &#34;this is is a debug level message\n&#34;);
RTE_LOG(INFO, TESTAPP1, &#34;this is is a info level message\n&#34;);
RTE_LOG(WARNING, TESTAPP1, &#34;this is is a warning level message\n&#34;);

/* log in info level */
rte_set_log_level(RTE_LOG_INFO);
RTE_LOG(DEBUG, TESTAPP2, &#34;debug level message (not displayed)\n&#34;);
</code></pre><h3 id=branch-prediction>Branch Prediction</h3><ul><li>When a test is done in a critical zone (called often or in a data
path) the code made use the <code>likely()</code> and <code>unlikely()</code> macros to
indicate the expected, or preferred fast path. They are expanded as
a compiler builtin and allow the developer to indicate if the branch
is likely to be taken or not. Example:</li></ul><pre tabindex=0><code>#include &lt;rte_branch_prediction.h&gt;
if (likely(x &gt; 1))
  do_stuff();
</code></pre><blockquote><p><strong>note</strong></p><p>The use of <code>likely()</code> and <code>unlikely()</code> should only be done in
performance critical paths, and only when there is a clearly preferred
path, or a measured performance increase gained from doing so. These
macros should be avoided in non-performance-critical code.</p></blockquote><h3 id=static-variables-and-functions>Static Variables and Functions</h3><ul><li>All functions and variables that are local to a file must be
declared as <code>static</code> because it can often help the compiler to do
some optimizations (such as, inlining the code).</li><li>Functions that should be inlined should to be declared as
<code>static inline</code> and can be defined in a .c or a .h file.</li></ul><blockquote><p><strong>note</strong></p><p>Static functions defined in a header file must be declared as
<code>static inline</code> in order to prevent compiler warnings about the
function being unused.</p></blockquote><h3 id=const-attribute>Const Attribute</h3><p>The <code>const</code> attribute should be used as often as possible when a
variable is read-only.</p><h3 id=inline-asm-in-c-code>Inline ASM in C code</h3><p>The <code>asm</code> and <code>volatile</code> keywords do not have underscores. The AT&amp;T
syntax should be used. Input and output operands should be named to
avoid confusion, as shown in the following example:</p><pre tabindex=0><code>asm volatile(&#34;outb %[val], %[port]&#34;
    : :
    [port] &#34;dN&#34; (port),
    [val] &#34;a&#34; (val));
</code></pre><h3 id=control-statements>Control Statements</h3><ul><li>Forever loops are done with for statements, not while statements.</li><li>Elements in a switch statement that cascade should have a
FALLTHROUGH comment. For example:</li></ul><pre tabindex=0><code>switch (ch) {         /* Indent the switch. */
case &#39;a&#39;:             /* Don&#39;t indent the case. */
        aflag = 1;    /* Indent case body one tab. */
        /* FALLTHROUGH */
case &#39;b&#39;:
        bflag = 1;
        break;
case &#39;?&#39;:
default:
        usage();
        /* NOTREACHED */
}
</code></pre><h2 id=environment-or-architecture-specific-sources>Environment or Architecture-specific Sources</h2><p>In DPDK and DPDK applications, some code is specific to an architecture
(i686, x86_64) or to an executive environment (bsdapp or linuxapp) and
so on. As far as is possible, all such instances of architecture or
env-specific code should be provided via standard APIs in the EAL.</p><p>By convention, a file is common if it is not located in a directory
indicating that it is specific. For instance, a file located in a subdir
of &ldquo;x86_64&rdquo; directory is specific to this architecture. A file located
in a subdir of &ldquo;linuxapp&rdquo; is specific to this execution environment.</p><blockquote><p><strong>note</strong></p><p>Code in DPDK libraries and applications should be generic. The correct
location for architecture or executive environment specific code is in
the EAL.</p></blockquote><p>When absolutely necessary, there are several ways to handle specific
code:</p><ul><li>Use a <code>#ifdef</code> with the CONFIG option in the C code. This can be
done when the differences are small and they can be embedded in the
same C file:</li></ul><ul><li>Use the CONFIG option in the Makefile. This is done when the
differences are more significant. In this case, the code is split
into two separate files that are architecture or environment
specific. This should only apply inside the EAL library.</li></ul><h3 id=per-architecture-sources>Per Architecture Sources</h3><p>The following config options can be used:</p><ul><li>CONFIG_RTE_ARCH is a string that contains the name of the
architecture.</li><li>CONFIG_RTE_ARCH_I686, CONFIG_RTE_ARCH_X86_64,
CONFIG_RTE_ARCH_X86_64_32 or CONFIG_RTE_ARCH_PPC_64 are
defined only if we are building for those architectures.</li></ul><h3 id=per-execution-environment-sources>Per Execution Environment Sources</h3><p>The following config options can be used:</p><ul><li>CONFIG_RTE_EXEC_ENV is a string that contains the name of the
executive environment.</li><li>CONFIG_RTE_EXEC_ENV_BSDAPP or CONFIG_RTE_EXEC_ENV_LINUXAPP
are defined only if we are building for this execution environment.</li></ul><h2 id=doxygen-documentation>Doxygen Documentation</h2><p>The API documentation is automatically generated in the DPDK framework.
That is why all files that are part of the public API must be documented
using Doxygen syntax.</p><p>The public API comprises functions of DPDK that can be used by an
external application that will use the SDK. Only the Doxygen syntax
described in the coding rules (this document) should be used in the
code. All the Doxygen features are described in the Doxygen manual
online.</p><h3 id=documenting-a-function>Documenting a Function</h3><p>All public functions must be documented. The documentation is placed in
the header file, above the declaration of the function. The definition
of the function may be documented, but using standard comments (not in
doxygen format). The following is an example of function documentation:</p><pre tabindex=0><code>/**
 * Summary here; one sentence on one line (should not exceed 80 chars).
 *
 * A more detailed description goes here.
 *
 * A blank line forms a paragraph. There should be no trailing white-space
 * anywhere.
 *
 * @param first
 *   &#34;@param&#34; is a Doxygen directive to describe a function parameter. Like
 *   some other directives, it takes a term/summary on the same line and a
 *   description (this text) indented by 2 spaces on the next line. All
 *   descriptive text should wrap at 80 chars, without going over.
 *   Newlines are NOT supported within directives; if a newline would be
 *   before this text, it would be appended to the general description above.
 * @param second
 *   There should be no newline between multiple directives (of the same
 *   type).
 *
 * @return
 *   &#34;@return&#34; is a different Doxygen directive to describe the return value
 *   of a function, if there is any.
 */
int rte_foo(int first, int second)
</code></pre><h3 id=documenting-files>Documenting Files</h3><p>Each public file may start with a comment describing what the file does.
For example:</p><pre tabindex=0><code>/**
 * @file
 * This file describes the coding rules of RTE.
 *
 * It contains the coding rules of C code, ASM code, reStructured
 * Text documentation, and of course how to use doxygen to document
 * public API.
 */
</code></pre><h3 id=documenting-constants-and-variables>Documenting Constants and Variables</h3><p>Examples:</p><pre tabindex=0><code>/**
 * The definition of a funny TRUE.
 */
#define TRUE 0

#define TRUE 1 /**&lt; another way to document a macro */

/**
 * Frequency of the HPET counter in Hz
 *
 * @see rte_eal_hpet_init()
 */
extern uint64_t eal_hpet_resolution_hz;
</code></pre><h3 id=documenting-structures>Documenting Structures</h3><p>Public structures should also be documented. The <code>/**&lt;</code> sequence can be
used to documented the fields of the structure, as shown in the
following example:</p><pre tabindex=0><code>/**
 * Structure describing a memzone, which is a contiguous portions of
 * physical memory identified by a name.
 */
struct rte_memzone {

#define MEMZONE_NAMESIZE 32
  char name[MEMZONE_NAMESIZE]; /**&lt; name of the memory zone */

  phys_addr_t phys_addr;       /**&lt; start physical address */
  void *addr;                  /**&lt; start virtual address */
  uint64_t len;                /**&lt; len of the memzone */

  int socket_id;               /**&lt; NUMA socket id */
};
</code></pre><h3 id=see-also-sections>See Also Sections</h3><p>The @see keyword can be used to highlight a link to an existing
function, file, or URL. This directive should be placed on one line,
without anything else, at the bottom of the documentation header.</p><pre tabindex=0><code>/**
 * (documentation of function, file, ...)
 *
 * @see rte_foo()
 * @see eal_memzone.c
 */
</code></pre></content><p><a href=https://cychong47.github.io/tags/dpdk/>#DPDK</a>
<a href=https://cychong47.github.io/tags/coding-style/>#Coding Style</a>
<a href=https://cychong47.github.io/tags/c/>#C</a></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>