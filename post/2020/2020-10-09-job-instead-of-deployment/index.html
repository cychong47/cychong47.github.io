<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>일회성 앱은 Deployment가 아닌 Job으로 | Keep calm and Write something</title><meta name=title content="일회성 앱은 Deployment가 아닌 Job으로"><meta name=description content="한 번 실행되면 데몬 처럼 계속해서 동작하는 앱이 아니라 필요한 일을 수행하고 종료되는 앱도 있다. 실행된 시점에 필요한 일을 수행하고 종료하는 형태로 예를 들면 특정 위치에 있는 파일을 처리하고 종료한다거나, 실행된 시점에 외부 서비스에서 필요한 정보를 가져와 어딘가 저장하는 등의 일을 하는. 이런 종류의 앱을 kubernetes에서 Deployment로 배포한 경우 해당 앱은 자신이 해야 할 일을 정상적으로 수행하고 종료되지만, kubernetes scheduler 입장에서는 해당 container가 (의도하지 않게) 종료된 것으로 판단하여 다시 복구하는 절차를 수행한다. 이는 Deployment로 배포된 container는 scheduler를 통해 배포된 것처럼 scheduler를 통해 제거되지 않으면 비정상이라고 판단하기 때문이다."><meta name=keywords content="kubernetes,job,"><meta property="og:url" content="https://cychong47.github.io/post/2020/2020-10-09-job-instead-of-deployment/"><meta property="og:site_name" content="Keep calm and Write something"><meta property="og:title" content="일회성 앱은 Deployment가 아닌 Job으로"><meta property="og:description" content="한 번 실행되면 데몬 처럼 계속해서 동작하는 앱이 아니라 필요한 일을 수행하고 종료되는 앱도 있다. 실행된 시점에 필요한 일을 수행하고 종료하는 형태로 예를 들면 특정 위치에 있는 파일을 처리하고 종료한다거나, 실행된 시점에 외부 서비스에서 필요한 정보를 가져와 어딘가 저장하는 등의 일을 하는. 이런 종류의 앱을 kubernetes에서 Deployment로 배포한 경우 해당 앱은 자신이 해야 할 일을 정상적으로 수행하고 종료되지만, kubernetes scheduler 입장에서는 해당 container가 (의도하지 않게) 종료된 것으로 판단하여 다시 복구하는 절차를 수행한다. 이는 Deployment로 배포된 container는 scheduler를 통해 배포된 것처럼 scheduler를 통해 제거되지 않으면 비정상이라고 판단하기 때문이다."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-10-09T01:00:00+09:00"><meta property="article:modified_time" content="2020-10-09T01:00:00+09:00"><meta property="article:tag" content="Kubernetes"><meta property="article:tag" content="Job"><meta property="og:see_also" content="https://cychong47.github.io/post/2020/2020-10-19-use-the-secret-and-configmaps/"><meta property="og:see_also" content="https://cychong47.github.io/post/2020/2020-10-19-how-to-fix-no-timezone-support-of-cronjob/"><meta property="og:see_also" content="https://cychong47.github.io/post/2020/2020-10-09-cronjob-in-kubernetes/"><meta property="og:see_also" content="https://cychong47.github.io/post/2020/2020-09-10-helmize-slackbot/"><meta property="og:see_also" content="https://cychong47.github.io/post/2020/new-things-in-last-4-years/"><meta name=twitter:card content="summary"><meta name=twitter:title content="일회성 앱은 Deployment가 아닌 Job으로"><meta name=twitter:description content="한 번 실행되면 데몬 처럼 계속해서 동작하는 앱이 아니라 필요한 일을 수행하고 종료되는 앱도 있다. 실행된 시점에 필요한 일을 수행하고 종료하는 형태로 예를 들면 특정 위치에 있는 파일을 처리하고 종료한다거나, 실행된 시점에 외부 서비스에서 필요한 정보를 가져와 어딘가 저장하는 등의 일을 하는. 이런 종류의 앱을 kubernetes에서 Deployment로 배포한 경우 해당 앱은 자신이 해야 할 일을 정상적으로 수행하고 종료되지만, kubernetes scheduler 입장에서는 해당 container가 (의도하지 않게) 종료된 것으로 판단하여 다시 복구하는 절차를 수행한다. 이는 Deployment로 배포된 container는 scheduler를 통해 배포된 것처럼 scheduler를 통해 제거되지 않으면 비정상이라고 판단하기 때문이다."><meta itemprop=name content="일회성 앱은 Deployment가 아닌 Job으로"><meta itemprop=description content="한 번 실행되면 데몬 처럼 계속해서 동작하는 앱이 아니라 필요한 일을 수행하고 종료되는 앱도 있다. 실행된 시점에 필요한 일을 수행하고 종료하는 형태로 예를 들면 특정 위치에 있는 파일을 처리하고 종료한다거나, 실행된 시점에 외부 서비스에서 필요한 정보를 가져와 어딘가 저장하는 등의 일을 하는. 이런 종류의 앱을 kubernetes에서 Deployment로 배포한 경우 해당 앱은 자신이 해야 할 일을 정상적으로 수행하고 종료되지만, kubernetes scheduler 입장에서는 해당 container가 (의도하지 않게) 종료된 것으로 판단하여 다시 복구하는 절차를 수행한다. 이는 Deployment로 배포된 container는 scheduler를 통해 배포된 것처럼 scheduler를 통해 제거되지 않으면 비정상이라고 판단하기 때문이다."><meta itemprop=datePublished content="2020-10-09T01:00:00+09:00"><meta itemprop=dateModified content="2020-10-09T01:00:00+09:00"><meta itemprop=wordCount content="726"><meta itemprop=keywords content="Kubernetes,Job"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style></head><body><header><a href=/ class=title><h2>Keep calm and Write something</h2></a><nav><a href=/post/>Post</a>
<a href=/page/>Page</a>
<a href=/series/>Series</a>
<a href=/tags/>Tag</a>
<a href=/archive/>Archive</a>
<a href=/search/>Search</a></nav></header><main><content><p>한 번 실행되면 데몬 처럼 계속해서 동작하는 앱이 아니라 필요한 일을 수행하고 종료되는 앱도 있다. 실행된 시점에 필요한 일을 수행하고 종료하는 형태로 예를 들면 특정 위치에 있는 파일을 처리하고 종료한다거나, 실행된 시점에 외부 서비스에서 필요한 정보를 가져와 어딘가 저장하는 등의 일을 하는. 이런 종류의 앱을 kubernetes에서 <code>Deployment</code>로 배포한 경우 해당 앱은 자신이 해야 할 일을 정상적으로 수행하고 종료되지만, kubernetes scheduler 입장에서는 해당 container가 (의도하지 않게) 종료된 것으로 판단하여 다시 복구하는 절차를 수행한다. 이는 <code>Deployment</code>로 배포된 container는 scheduler를 통해 배포된 것처럼 scheduler를 통해 제거되지 않으면 비정상이라고 판단하기 때문이다.</p><p>이때 만일 복구하는데 한도를 두지 않으면 계속해서 앱이 실행되었다 종료되고, 다시 복구되는 작업을 반복하게 되는데 이는 불필요한 에러 로그만 지속적으로 생산하는 상황이 된다.</p><h2 id=use-job-instead-of-deployment>Use <code>Job</code> instead of <code>Deployment</code></h2><p>만일 앱이 실행된 후 필요한 일을 모두 마치고 종료되는 것이 의도된 동작이라면 해당 Pod의 <code>kind</code>를 <code>Deployment</code>가 아니라 <code>Job</code> 형태로 정의한다.</p><p>다만 <code>Job</code>을 이용한 chart를 준비할 때 사소한 이슈라면 <code>helm create</code> 명령으로 만들어진 helm chart template는 기본적으로 <code>Deployment</code>와 <code>Service</code>등만 만들어 <code>Job</code> 을 위한 YAML 파일을 만들 쉬운 방법이 없다는 점이다.(<code>helm create</code> 명령의 도움말이나 구글링 결과, 2020.10월 기준)</p><p>대부분 <code>Job</code>에 대해 설명하는 문서에서는 간단한 YAML 파일을 기준으로 설명하고 있어, helm chart를 사용해서 배포하려는 경우에는 어떻게 chart를 만들어야 할 지 난감하다.</p><h2 id=mysqldump-vs-mysql><code>mysqldump</code> vs. <code>mysql</code></h2><p>다행히 <code>github</code>에 있는 공식 helm chart를 보면 많은 기여자들이 만든 좋은 예제를 참조할 수 있다.(이것도 역시 open-source가 주는 장점)
그래서 <code>Job</code> 키워드로 검색을 해 보니 몇 개의 chart가 이를 사용하는 것으로 확인되었다. 그 중에 하나 고른 것이 <code>mysqldump</code>.
이름 그래도 <code>mysql</code>의 database를 백업하는 툴 같은데, <code>mysql shell</code>을 이용하거나 API를 이용해서 DB에 연결해서 정보를 백업하는 형태일 것 같다.</p><p>이때 서버 역할을 할 <code>mysql</code>은 당연히 늘 실행되어 있는 형태일 거라 일반적인 <code>Deployment</code>를 사용할 듯 하고.
그래서 <code>Job</code>을 사용하는 <code>mysqldump</code> chart와 <code>Deployment</code>를 사용하는 <code>mysql</code>의 chart를 비교해 보면 <code>Job</code>을 사용하는 chart를 어떻게 만들면 되는 지 감을 잡을 수 있을 듯 하다.</p><h3 id=jobyaml-instead-of-deploymentyaml><code>job.yaml</code> instead of <code>deployment.yaml</code></h3><p><code>mysqldump</code>의 경우 <code>deployment.yaml</code> 대신 <code>job.yaml</code> 파일과 <code>cron.yaml</code> 파일을 가지고 있었다. 그 외 <code>configmap</code>은 <code>mysql</code>과 <code>mysqldump</code>에서 파일 이름만 다를 뿐 양쪽에서 모두 사용하고 있으므로 차이점은 아니고.</p><pre tabindex=0><code>cychong@mini1:~/work/Helm/reference/official-helm-charts/stable/mysqldump/templates$ ls -al
total 44
drwxrwxr-x 2 cychong cychong 4096 Oct  9 09:12 .
drwxrwxr-x 4 cychong cychong 4096 Sep 20  2019 ..
-rw-rw-r-- 1 cychong cychong 1934 Sep 20  2019 NOTES.txt
-rw-rw-r-- 1 cychong cychong 1869 Sep 20  2019 _helpers.tpl
-rwxrwxr-x 1 cychong cychong 5478 Sep 20  2019 configmap.yaml
-rw-rw-r-- 1 cychong cychong  806 Sep 20  2019 cron.yaml
-rw-rw-r-- 1 cychong cychong  691 Sep 20  2019 gcpserviceaccount.yaml
-rw-rw-r-- 1 cychong cychong  298 Sep 20  2019 job.yaml
-rw-rw-r-- 1 cychong cychong  625 Sep 20  2019 pvc.yaml
-rw-rw-r-- 1 cychong cychong 1238 Sep 20  2019 secret.yaml

cychong@mini1:~/work/Helm/reference/official-helm-charts/stable/mysq/templates/ls -al
total 52
drwxrwxr-x 3 cychong cychong 4096 Sep 20  2019 .
drwxrwxr-x 3 cychong cychong 4096 Sep 20  2019 ..
-rw-rw-r-- 1 cychong cychong 1797 Sep 20  2019 NOTES.txt
-rw-rw-r-- 1 cychong cychong  989 Sep 20  2019 _helpers.tpl
-rw-rw-r-- 1 cychong cychong  292 Sep 20  2019 configurationFiles-configmap.yaml
-rw-rw-r-- 1 cychong cychong 8137 Sep 20  2019 deployment.yaml
-rw-rw-r-- 1 cychong cychong  295 Sep 20  2019 initializationFiles-configmap.yaml
-rw-rw-r-- 1 cychong cychong  868 Sep 20  2019 pvc.yaml
-rwxrwxr-x 1 cychong cychong 1245 Sep 20  2019 secrets.yaml
-rw-rw-r-- 1 cychong cychong  800 Sep 20  2019 servicemonitor.yaml
-rw-rw-r-- 1 cychong cychong 1104 Sep 20  2019 svc.yaml
drwxrwxr-x 2 cychong cychong 4096 Sep 20  2019 tests
</code></pre><h2 id=jobyaml><code>job.yaml</code></h2><p>한번 실행되면 명시적으로 중지시키지 않는 이상 계속해서 실행되는 <code>deployment</code>와 달리 한번 실행되어 필요한 작업을 완료한 후 종료되는 app은 <code>kind</code>를 <code>Deployment</code>가 아닌 <code>Job</code>으로 지정한다.</p><pre tabindex=0><code>$ helm install -f pocket-stat-value.yaml pocket-stat helm-chart/charts/pocket-stat
NAME: pocket-stat
LAST DEPLOYED: Fri Oct  9 16:24:22 2020
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
1. Get the application URL by running these commands:
  export NODE_PORT=$(kubectl get --namespace default -o jsonpath=&#34;{.spec.ports[0].nodePort}&#34; services pocket-stat)
  export NODE_IP=$(kubectl get nodes --namespace default -o jsonpath=&#34;{.items[0].status.addresses[0].address}&#34;)
  echo http://$NODE_IP:$NODE_PORT
</code></pre><p><code>Job</code> 타입의 정보는 <code>kubectl get jobs</code> 명령으로 확인할 수 있다.</p><pre tabindex=0><code>$ kubectl get jobs
NAME          COMPLETIONS   DURATION   AGE
pocket-stat   0/1           6s         6s
</code></pre><p>그리고 해당 <code>Job</code>에서 생성했던 <code>Pod</code> 역시 아래와 같이 <code>kubectl get pods</code>명령으로 확인이 가능한데, 다른 <code>Deployment</code> 형태의 Pod와 달리 <code>STATUS</code>가 <code>Completed</code>임을 알 수 있다. 즉 필요한 일을 마치 종료되었는데 이를 말 그대로 “Complete” 된 것으로 판단하고, 다시 재실행시키지 않는다는 의미이다.</p><pre tabindex=0><code>$ kubectl get pods
NAME                             READY   STATUS      RESTARTS   AGE
grafana-6b66fb5758-gmvgf         1/1     Running     1          4d17h
influxdb-0                       1/1     Running     1          6d6h
pocket-stat-ksrvr                0/1     Completed   0          12s
podcast-nginx-659bcb6485-ps7qq   1/1     Running     1          6d7h
sosa0sa-nginx-87fc9949c-wb4jp    1/1     Running     1          6d7h
</code></pre><p>Pod의 실행 결과는 여느 Pod 와 동일하게 <code>kubectl logs</code> 명령으로 확인 가능.</p><pre tabindex=0><code>$ kubectl logs pocket-stat-ksrvr
Check articles added since 2020-10-08 00:00:00
16 are collected in yesterday
</code></pre></content><p><a href=https://cychong47.github.io/tags/kubernetes/>#Kubernetes</a>
<a href=https://cychong47.github.io/tags/job/>#Job</a></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>