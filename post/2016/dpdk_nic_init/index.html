<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>DPDK NIC 초기화 | Keep calm and Write something</title><meta name=title content="DPDK NIC 초기화"><meta name=description content='constructor attribute
http://phoxis.org/2011/04/27/c-language-constructors-and-destructors-with-gcc/
constructor attribute을 가진 함수는 main 함수를 실행하기 전에 호출한다.
예제 (출처)
#include <stdio.h>
 
void begin (void) __attribute__((constructor));
void end (void) __attribute__((destructor));
 
int main (void)
{
  printf ("\nInside main ()");
}
 
void begin (void)
{
  printf ("\nIn begin ()");
}
 
void end (void)
{
  printf ("\nIn end ()\n");
}
실행하면
In begin ()
Inside main ()
In end ()
DPDK
DPDK의 경우 device driver들을 모두 constructor attirbute을 사용해서 main 함수 전에 호출되록 한다.'><meta name=keywords content="DPDK,"><meta property="og:url" content="https://cychong47.github.io/post/2016/dpdk_nic_init/"><meta property="og:site_name" content="Keep calm and Write something"><meta property="og:title" content="DPDK NIC 초기화"><meta property="og:description" content='constructor attribute http://phoxis.org/2011/04/27/c-language-constructors-and-destructors-with-gcc/
constructor attribute을 가진 함수는 main 함수를 실행하기 전에 호출한다.
예제 (출처)
#include <stdio.h> void begin (void) __attribute__((constructor)); void end (void) __attribute__((destructor)); int main (void) { printf ("\nInside main ()"); } void begin (void) { printf ("\nIn begin ()"); } void end (void) { printf ("\nIn end ()\n"); } 실행하면
In begin () Inside main () In end () DPDK DPDK의 경우 device driver들을 모두 constructor attirbute을 사용해서 main 함수 전에 호출되록 한다.'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2016-02-09T14:54:21+09:00"><meta property="article:modified_time" content="2018-04-01T02:38:40+00:00"><meta property="article:tag" content="DPDK"><meta name=twitter:card content="summary"><meta name=twitter:title content="DPDK NIC 초기화"><meta name=twitter:description content='constructor attribute http://phoxis.org/2011/04/27/c-language-constructors-and-destructors-with-gcc/
constructor attribute을 가진 함수는 main 함수를 실행하기 전에 호출한다.
예제 (출처)
#include <stdio.h> void begin (void) __attribute__((constructor)); void end (void) __attribute__((destructor)); int main (void) { printf ("\nInside main ()"); } void begin (void) { printf ("\nIn begin ()"); } void end (void) { printf ("\nIn end ()\n"); } 실행하면
In begin () Inside main () In end () DPDK DPDK의 경우 device driver들을 모두 constructor attirbute을 사용해서 main 함수 전에 호출되록 한다.'><meta itemprop=name content="DPDK NIC 초기화"><meta itemprop=description content='constructor attribute http://phoxis.org/2011/04/27/c-language-constructors-and-destructors-with-gcc/
constructor attribute을 가진 함수는 main 함수를 실행하기 전에 호출한다.
예제 (출처)
#include <stdio.h> void begin (void) __attribute__((constructor)); void end (void) __attribute__((destructor)); int main (void) { printf ("\nInside main ()"); } void begin (void) { printf ("\nIn begin ()"); } void end (void) { printf ("\nIn end ()\n"); } 실행하면
In begin () Inside main () In end () DPDK DPDK의 경우 device driver들을 모두 constructor attirbute을 사용해서 main 함수 전에 호출되록 한다.'><meta itemprop=datePublished content="2016-02-09T14:54:21+09:00"><meta itemprop=dateModified content="2018-04-01T02:38:40+00:00"><meta itemprop=wordCount content="530"><meta itemprop=keywords content="DPDK"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style></head><body><header><a href=/ class=title><h2>Keep calm and Write something</h2></a><nav><a href=/post/>Post</a>
<a href=/page/>Page</a>
<a href=/series/>Series</a>
<a href=/tags/>Tag</a>
<a href=/archive/>Archive</a>
<a href=/search/>Search</a></nav></header><main><content><h3 id=constructor-attribute>constructor attribute</h3><p><a href=http://phoxis.org/2011/04/27/c-language-constructors-and-destructors-with-gcc/>http://phoxis.org/2011/04/27/c-language-constructors-and-destructors-with-gcc/</a></p><p>constructor attribute을 가진 함수는 main 함수를 실행하기 전에 호출한다.</p><p>예제 (<a href=http://phoxis.org/2011/04/27/c-language-constructors-and-destructors-with-gcc/>출처</a>)</p><pre tabindex=0><code>#include &lt;stdio.h&gt;
 
void begin (void) __attribute__((constructor));
void end (void) __attribute__((destructor));
 
int main (void)
{
  printf (&#34;\nInside main ()&#34;);
}
 
void begin (void)
{
  printf (&#34;\nIn begin ()&#34;);
}
 
void end (void)
{
  printf (&#34;\nIn end ()\n&#34;);
}
</code></pre><p>실행하면</p><pre tabindex=0><code>In begin ()
Inside main ()
In end ()
</code></pre><h3 id=dpdk>DPDK</h3><p>DPDK의 경우 device driver들을 모두 constructor attirbute을 사용해서 main 함수 전에 호출되록 한다.</p><pre tabindex=0><code>PMD_REGISTER_DRIVER(pmd_igb_drv);  
PMD_REGISTER_DRIVER(pmd_igbvf_drv);  
PMD_REGISTER_DRIVER(em_pmd_drv);  
</code></pre><p>Physical device 외에 virtual device들도 동일하게 등록한다.</p><pre tabindex=0><code>PMD_REGISTER_DRIVER(cryptodev_aesni_mb_pmd_drv);  
PMD_REGISTER_DRIVER(pmd_qat_drv);  
</code></pre><p><code>PMD_REGISTER_DRIVER()</code>는 <code>lib/librte_eal/common/include/rte_dev.h</code>에 다음과 같이 정의되어 있다.</p><pre tabindex=0><code>#define PMD_REGISTER_DRIVER(d)\
void devinitfn_ ##d(void);\
void __attribute__((constructor, used)) devinitfn_ ##d(void)\
{\
    rte_eal_driver_register(&amp;d);\
}
</code></pre><p><code>rte_eal_deriver_register()</code>는 <code>lib/librte_eal/common/eal_common_dev.c</code>에서 static 변수로 정의된 <code>rte_driver_list[]</code>에 함수 인자로 넘겨진 driver를 등록한다.</p><p>인자는 다음 struct 형태로 정의된다.</p><pre tabindex=0><code>/**  
 * A structure describing a device driver.  
 */  
struct rte_driver {   
    TAILQ_ENTRY(rte_driver) next;      /**&lt; Next in list. */  
    enum pmd_type type;                /**&lt; PMD Driver type */  
    const char *name;                  /**&lt; Driver name. */  
    rte_dev_init_t *init;              /**&lt; Device init. function. */  
    rte_dev_uninit_t *uninit;          /**&lt; Device uninit. function. */  
};  
</code></pre><p>등록된 디바이스들은 <code>rte_eal_init()</code> 초기화 과정에서 호출되는 함수 <code>rte_eal_dev_init()</code>에서 각 디바이스의 초기화 함수가 호출된다.</p><pre tabindex=0><code>int
rte_eal_dev_init(void)
{
    /* call the init function for each virtual device */
    TAILQ_FOREACH(devargs, &amp;devargs_list, next) {
        if (devargs-&gt;type != RTE_DEVTYPE_VIRTUAL)
            continue;

        if (rte_eal_vdev_init(devargs-&gt;virt.drv_name,
                    devargs-&gt;args)) {
        ...
    }

    /* Once the vdevs are initalized, start calling all the pdev drivers */
    TAILQ_FOREACH(driver, &amp;dev_driver_list, next) {
        if (driver-&gt;type != PMD_PDEV)
            continue;

        /* PDEV drivers don&#39;t get passed any parameters */
        driver-&gt;init(NULL, NULL);
    }
</code></pre><h4 id=qat-device>QAT device</h4><pre tabindex=0><code>static struct rte_driver pmd_qat_drv = {
    .type = PMD_PDEV,
    .init = rte_qat_pmd_init,
};
</code></pre><h5 id=qat-pmd-초기화>QAT PMD 초기화</h5><ol><li><code>rte_qat_pmd_init()</code></li><li><code>rte_cryptodev_pmd_driver_register()</code></li><li><code>rte_cryptodev_init()</code> & <code>rte_eal_pci_register()</code></li></ol><h4 id=aesni_mb-device>AESNI_MB device</h4><pre tabindex=0><code>static struct rte_driver cryptodev_aesni_mb_pmd_drv = {
    .name = CRYPTODEV_NAME_AESNI_MB_PMD,
    .type = PMD_VDEV,
    .init = cryptodev_aesni_mb_init,
    .uninit = cryptodev_aesni_mb_uninit
};
</code></pre><h5 id=aesni_mb-초기화>AESNI_MB 초기화</h5><ol><li><code>cryptodev_aesni_mb_init()</code></li><li><code>cryptodev_aesni_mb_create()</code></li></ol><ul><li>CPU가 AES 연산을 지원하는 지 확인</li><li>CPU가 AVX2/AVX/SSE4_1 중 최소 한 가지를 지원하는 지 확인</li><li><code>rte_cryptodev_pmd_virtual_dev_init()</code>를 이용해 PMD device로 등록</li></ul><h3 id=e1000>e1000</h3><pre tabindex=0><code>static int
rte_em_pmd_init(const char *name __rte_unused, const char *params __rte_unused)
{
    rte_eth_driver_register(&amp;rte_em_pmd);
    return 0;
}

struct rte_driver em_pmd_drv = {
    .type = PMD_PDEV,
    .init = rte_em_pmd_init,
};
</code></pre><p>Physical NIC은 <code>rte_eth_driver_register()</code>함수를 이용하여 <code>rte_eth_dev</code>에 등록된다. 이때 등록되는 디바이스 구조체는 다음과 같다.</p><pre tabindex=0><code>static struct eth_driver rte_em_pmd = {
    .pci_drv = {
        .name = &#34;rte_em_pmd&#34;,
        .id_table = pci_id_em_map,
        .drv_flags = RTE_PCI_DRV_NEED_MAPPING | RTE_PCI_DRV_INTR_LSC |
            RTE_PCI_DRV_DETACHABLE,
    },
    .eth_dev_init = eth_em_dev_init,
    .eth_dev_uninit = eth_em_dev_uninit,
    .dev_private_size = sizeof(struct e1000_adapter),
};
</code></pre><p><code>rte_eth</code> 구조체에 등록하는 함수 <code>rte_eth_driver_register()</code>는 다음과 같이 구현되어 있어, PCI device list에 NIC을 등록한다. 등록된 PCI device들은 <code>rte_eal_init()</code> 과정에서 호출되는 PCI scan 과정을 통해 실제 NIC을 찾는 과정을 거친다.</p><pre tabindex=0><code>/**
 * Register an Ethernet [Poll Mode] driver.
 *
 * Function invoked by the initialization function of an Ethernet driver
 * to simultaneously register itself as a PCI driver and as an Ethernet
 * Poll Mode Driver.
 * Invokes the rte_eal_pci_register() function to register the *pci_drv*
 * structure embedded in the *eth_drv* structure, after having stored the
 * address of the rte_eth_dev_init() function in the *devinit* field of
 * the *pci_drv* structure.
 * During the PCI probing phase, the rte_eth_dev_init() function is
 * invoked for each PCI [Ethernet device] matching the embedded PCI
 * identifiers provided by the driver.
 */
void
rte_eth_driver_register(struct eth_driver *eth_drv)
{
    eth_drv-&gt;pci_drv.devinit = rte_eth_dev_init;
    eth_drv-&gt;pci_drv.devuninit = rte_eth_dev_uninit;
    rte_eal_pci_register(&amp;eth_drv-&gt;pci_drv);
}
</code></pre></content><p><a href=https://cychong47.github.io/tags/dpdk/>#DPDK</a></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>