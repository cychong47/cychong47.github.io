<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>KNI가 buffer를 free 하는 방법 | Keep calm and Write something</title><meta name=title content="KNI가 buffer를 free 하는 방법"><meta name=description content="DPDK to KNI RX
KNI는 rx_q로부터 mbuf를 수신한 후 data_len 크기의 skb를 할당하여 데이터를 복사한 후 netif_rx를 호출한다.
그러므로 mbuf는 KNI kernel module까지만 사용되고, 커널 networking stack에서는 사용되지는 않는다.
kni_net.c의 kni_net_rx_normal() 함수가 DPDK application으로부터 mbuf를 받아 커널에 전달하는 함수인데 실제 함수는 batch processing을 위해 한번에 여러 개의 패킷을 rx_q로부터 읽어 처리하도록 구현되어 있다.
아래는 하나의 패킷에 대해 수행되는 코드를 간략화 한 것이다(예외 처리 부분도 제외)
num_rx = kni_fifo_get(kni->rx_q, (void **)va, num_rx);

kva = (void *)va[i] - kni->mbuf_va + kni->mbuf_kva;
len = kva->data_len;
data_kva = kva->buf_addr + kva->data_off - kni->mbuf_va + kni->mbuf_kva;

skb = dev_alloc_skb(len + 2);

/* Align IP on 16B boundary */
skb_reserve(skb, 2);
memcpy(skb_put(skb, len), data_kva, len);
skb->dev = dev;
skb->protocol = eth_type_trans(skb, dev);
skb->ip_summed = CHECKSUM_UNNECESSARY;

/* Call netif interface */
netif_rx(skb);

/* Update statistics */
kni->stats.rx_bytes += len;
kni->stats.rx_packets++;

/* Burst enqueue mbufs into free_q */
ret = kni_fifo_put(kni->free_q, (void **)va, num_rx);
In case DPDK application restarted"><meta name=keywords content="DPDK,kni,study,"><meta property="og:url" content="https://cychong47.github.io/post/2016/how_kni_free_mbuf/"><meta property="og:site_name" content="Keep calm and Write something"><meta property="og:title" content="KNI가 buffer를 free 하는 방법"><meta property="og:description" content="DPDK to KNI RX KNI는 rx_q로부터 mbuf를 수신한 후 data_len 크기의 skb를 할당하여 데이터를 복사한 후 netif_rx를 호출한다. 그러므로 mbuf는 KNI kernel module까지만 사용되고, 커널 networking stack에서는 사용되지는 않는다.
kni_net.c의 kni_net_rx_normal() 함수가 DPDK application으로부터 mbuf를 받아 커널에 전달하는 함수인데 실제 함수는 batch processing을 위해 한번에 여러 개의 패킷을 rx_q로부터 읽어 처리하도록 구현되어 있다.
아래는 하나의 패킷에 대해 수행되는 코드를 간략화 한 것이다(예외 처리 부분도 제외)
num_rx = kni_fifo_get(kni->rx_q, (void **)va, num_rx); kva = (void *)va[i] - kni->mbuf_va + kni->mbuf_kva; len = kva->data_len; data_kva = kva->buf_addr + kva->data_off - kni->mbuf_va + kni->mbuf_kva; skb = dev_alloc_skb(len + 2); /* Align IP on 16B boundary */ skb_reserve(skb, 2); memcpy(skb_put(skb, len), data_kva, len); skb->dev = dev; skb->protocol = eth_type_trans(skb, dev); skb->ip_summed = CHECKSUM_UNNECESSARY; /* Call netif interface */ netif_rx(skb); /* Update statistics */ kni->stats.rx_bytes += len; kni->stats.rx_packets++; /* Burst enqueue mbufs into free_q */ ret = kni_fifo_put(kni->free_q, (void **)va, num_rx); In case DPDK application restarted"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2016-03-06T08:17:58+09:00"><meta property="article:modified_time" content="2018-04-01T02:38:40+00:00"><meta property="article:tag" content="DPDK"><meta property="article:tag" content="Kni"><meta property="article:tag" content="Study"><meta name=twitter:card content="summary"><meta name=twitter:title content="KNI가 buffer를 free 하는 방법"><meta name=twitter:description content="DPDK to KNI RX KNI는 rx_q로부터 mbuf를 수신한 후 data_len 크기의 skb를 할당하여 데이터를 복사한 후 netif_rx를 호출한다. 그러므로 mbuf는 KNI kernel module까지만 사용되고, 커널 networking stack에서는 사용되지는 않는다.
kni_net.c의 kni_net_rx_normal() 함수가 DPDK application으로부터 mbuf를 받아 커널에 전달하는 함수인데 실제 함수는 batch processing을 위해 한번에 여러 개의 패킷을 rx_q로부터 읽어 처리하도록 구현되어 있다.
아래는 하나의 패킷에 대해 수행되는 코드를 간략화 한 것이다(예외 처리 부분도 제외)
num_rx = kni_fifo_get(kni->rx_q, (void **)va, num_rx); kva = (void *)va[i] - kni->mbuf_va + kni->mbuf_kva; len = kva->data_len; data_kva = kva->buf_addr + kva->data_off - kni->mbuf_va + kni->mbuf_kva; skb = dev_alloc_skb(len + 2); /* Align IP on 16B boundary */ skb_reserve(skb, 2); memcpy(skb_put(skb, len), data_kva, len); skb->dev = dev; skb->protocol = eth_type_trans(skb, dev); skb->ip_summed = CHECKSUM_UNNECESSARY; /* Call netif interface */ netif_rx(skb); /* Update statistics */ kni->stats.rx_bytes += len; kni->stats.rx_packets++; /* Burst enqueue mbufs into free_q */ ret = kni_fifo_put(kni->free_q, (void **)va, num_rx); In case DPDK application restarted"><meta itemprop=name content="KNI가 buffer를 free 하는 방법"><meta itemprop=description content="DPDK to KNI RX KNI는 rx_q로부터 mbuf를 수신한 후 data_len 크기의 skb를 할당하여 데이터를 복사한 후 netif_rx를 호출한다. 그러므로 mbuf는 KNI kernel module까지만 사용되고, 커널 networking stack에서는 사용되지는 않는다.
kni_net.c의 kni_net_rx_normal() 함수가 DPDK application으로부터 mbuf를 받아 커널에 전달하는 함수인데 실제 함수는 batch processing을 위해 한번에 여러 개의 패킷을 rx_q로부터 읽어 처리하도록 구현되어 있다.
아래는 하나의 패킷에 대해 수행되는 코드를 간략화 한 것이다(예외 처리 부분도 제외)
num_rx = kni_fifo_get(kni->rx_q, (void **)va, num_rx); kva = (void *)va[i] - kni->mbuf_va + kni->mbuf_kva; len = kva->data_len; data_kva = kva->buf_addr + kva->data_off - kni->mbuf_va + kni->mbuf_kva; skb = dev_alloc_skb(len + 2); /* Align IP on 16B boundary */ skb_reserve(skb, 2); memcpy(skb_put(skb, len), data_kva, len); skb->dev = dev; skb->protocol = eth_type_trans(skb, dev); skb->ip_summed = CHECKSUM_UNNECESSARY; /* Call netif interface */ netif_rx(skb); /* Update statistics */ kni->stats.rx_bytes += len; kni->stats.rx_packets++; /* Burst enqueue mbufs into free_q */ ret = kni_fifo_put(kni->free_q, (void **)va, num_rx); In case DPDK application restarted"><meta itemprop=datePublished content="2016-03-06T08:17:58+09:00"><meta itemprop=dateModified content="2018-04-01T02:38:40+00:00"><meta itemprop=wordCount content="350"><meta itemprop=keywords content="DPDK,Kni,Study"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style></head><body><header><a href=/ class=title><h2>Keep calm and Write something</h2></a><nav><a href=/post/>Post</a>
<a href=/page/>Page</a>
<a href=/series/>Series</a>
<a href=/tags/>Tag</a>
<a href=/archive/>Archive</a>
<a href=/search/>Search</a></nav></header><main><content><h1 id=dpdk-to-kni-rx>DPDK to KNI RX</h1><p>KNI는 <code>rx_q</code>로부터 mbuf를 수신한 후 <code>data_len</code> 크기의 skb를 할당하여 데이터를 복사한 후 <code>netif_rx</code>를 호출한다.
그러므로 mbuf는 KNI kernel module까지만 사용되고, 커널 networking stack에서는 사용되지는 않는다.</p><p><code>kni_net.c</code>의 <code>kni_net_rx_normal()</code> 함수가 DPDK application으로부터 mbuf를 받아 커널에 전달하는 함수인데 실제 함수는 batch processing을 위해 한번에 여러 개의 패킷을 <code>rx_q</code>로부터 읽어 처리하도록 구현되어 있다.</p><p>아래는 하나의 패킷에 대해 수행되는 코드를 간략화 한 것이다(예외 처리 부분도 제외)</p><pre tabindex=0><code>num_rx = kni_fifo_get(kni-&gt;rx_q, (void **)va, num_rx);

kva = (void *)va[i] - kni-&gt;mbuf_va + kni-&gt;mbuf_kva;
len = kva-&gt;data_len;
data_kva = kva-&gt;buf_addr + kva-&gt;data_off - kni-&gt;mbuf_va + kni-&gt;mbuf_kva;

skb = dev_alloc_skb(len + 2);

/* Align IP on 16B boundary */
skb_reserve(skb, 2);
memcpy(skb_put(skb, len), data_kva, len);
skb-&gt;dev = dev;
skb-&gt;protocol = eth_type_trans(skb, dev);
skb-&gt;ip_summed = CHECKSUM_UNNECESSARY;

/* Call netif interface */
netif_rx(skb);

/* Update statistics */
kni-&gt;stats.rx_bytes += len;
kni-&gt;stats.rx_packets++;

/* Burst enqueue mbufs into free_q */
ret = kni_fifo_put(kni-&gt;free_q, (void **)va, num_rx);
</code></pre><p>In case DPDK application restarted</p><p>만일 DPPK application이 비정상적으로 종료되어 다시 실행하는 경우 버퍼를 초기화 과정에서 문제가 발생할 수 있다.</p><h3 id=1-dpdk---kni>1. DPDK -> KNI</h3><p><code>rx_q</code>나 <code>free_q</code>에는 이전 DPDK application에서 KNI에 전달했던 mbuf정보이다. 해당 버퍼 영역은 더 이상 유효하지 않고, <code>rx_q</code>, <code>free_q</code> 조차도 유효하지 않다. 그러므로 새로 실행된 DPDK application이 <code>rx_q</code>, <code>free_q</code>에 접근하여 queue에 존재하는 버퍼를 처리하는 것 조차 문제될 수 있다(확실한가???)</p><h3 id=2-kni---dpdk>2. KNI -> DPDK</h3><p><code>tx_q</code>나 <code>alloc_q</code> 역시 <code>rx_q</code>, <code>free_q</code> 와 동일한 이슈를 갖는다. Tx를 위해 사용할 mbuf를 미리 할당해 놓은 <code>alloc_q</code>에 존재하는 mbuf는 이전 DPDK application이 할당한 것이고, <code>tx_q</code> 에 존재하는 mbuf 역시 동일하다.</p><p><code>struct rte_kni_mbuf</code>는 DPDK와 KNI kernel module간 통신할 때 사용되는 구조체로 <code>rte_mbuf</code> 중 KNI에게 필요한 정보만 모은 것이다.</p><pre tabindex=0><code>/*
 * The kernel image of the rte_mbuf struct, with only the relevant fields.
 * Padding is necessary to assure the offsets of these fields
 */
struct rte_kni_mbuf {
        void *buf_addr __attribute__((__aligned__(RTE_CACHE_LINE_SIZE)));
        char pad0[10];
        uint16_t data_off;      /**&lt; Start address of data in segment buffer. */
        char pad1[4];
        uint64_t ol_flags;      /**&lt; Offload features. */
        char pad2[4];
        uint32_t pkt_len;       /**&lt; Total pkt len: sum of all segment data_len. */
        uint16_t data_len;      /**&lt; Amount of data in segment buffer. */

        /* fields on second cache line */
        char pad3[8] __attribute__((__aligned__(RTE_CACHE_LINE_SIZE)));
        void *pool;
        void *next;
};
</code></pre></content><p><a href=https://cychong47.github.io/tags/dpdk/>#DPDK</a>
<a href=https://cychong47.github.io/tags/kni/>#Kni</a>
<a href=https://cychong47.github.io/tags/study/>#Study</a></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>