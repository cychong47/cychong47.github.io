<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>DPDK IPv4 reassembly | Keep calm and Write something</title><meta name=title content="DPDK IPv4 reassembly"><meta name=description content="rte_ipv4_frag_reassemble_packet()

ip_frag_find()

기존에 존재하는 flow면 해당 flow를 저장한 entry 정보를(ip_frag_pkt *pkg)
신규 flow인 경우 해당 신규 flow를 저장할 신규 혹은 재사용된 entry를 return함
추가할 수 있는 통계

신규 flow?
기존 flow에 정상 추가
기존 flow에 비정상 추가(기존 flow가 timeouted)
이도 저도 아닌 상황(할당 실패)
LRU entry free
tbl->max_entries
tbl->use_entries


return

기존 존재하는 flow, 신규 할당한 flow entry 혹은 NULL
만일 NULL을 return하면 현재 수신한 mbuf를 death row에 추가한다. 불쌍한&mldr;


ip_frag_lookup()

if matched entry is exist

return flow entry
return &amp;stale if time-outed entry is exist


if new entry

return NULL
return free for new empty entry
return &amp;stale if time-outed entry is exist


ip_frag_key_cmp() return 0 if key matched


if ip_frag_lookup() returns NULL

if stale entry is not NULL, remove it with ip_frag_tbl_del() and save to free for reuse
even if free is not NULL, check if tbl->use_entries does not exceed tbl->max_entries. If so, check if the LRU entry is timeouted, then free the LRU entry. Otherwise, fail to add new entry to the tbl
tbl에서 할당하는 것고 max_entries, use_entries간의 차이점은??
If free is not NULL, add new flow to this free entry


if ip_frag_lookup() returns non-NULL

if timeouted, reuse it for the received flow


tbl->use_entries—; del_num++


ip_frag_process()
rte_ip_frag_free_death_row() 주기적으로 호출해줘야 함
"><meta name=keywords content="DPDK,reassembly,ipv4,"><meta property="og:url" content="https://cychong47.github.io/post/2016/dpdk-ipv4-reassembly/"><meta property="og:site_name" content="Keep calm and Write something"><meta property="og:title" content="DPDK IPv4 reassembly"><meta property="og:description" content="rte_ipv4_frag_reassemble_packet()
ip_frag_find() 기존에 존재하는 flow면 해당 flow를 저장한 entry 정보를(ip_frag_pkt *pkg) 신규 flow인 경우 해당 신규 flow를 저장할 신규 혹은 재사용된 entry를 return함 추가할 수 있는 통계 신규 flow? 기존 flow에 정상 추가 기존 flow에 비정상 추가(기존 flow가 timeouted) 이도 저도 아닌 상황(할당 실패) LRU entry free tbl->max_entries tbl->use_entries return 기존 존재하는 flow, 신규 할당한 flow entry 혹은 NULL 만일 NULL을 return하면 현재 수신한 mbuf를 death row에 추가한다. 불쌍한… ip_frag_lookup() if matched entry is exist return flow entry return &amp;stale if time-outed entry is exist if new entry return NULL return free for new empty entry return &amp;stale if time-outed entry is exist ip_frag_key_cmp() return 0 if key matched if ip_frag_lookup() returns NULL if stale entry is not NULL, remove it with ip_frag_tbl_del() and save to free for reuse even if free is not NULL, check if tbl->use_entries does not exceed tbl->max_entries. If so, check if the LRU entry is timeouted, then free the LRU entry. Otherwise, fail to add new entry to the tbl tbl에서 할당하는 것고 max_entries, use_entries간의 차이점은?? If free is not NULL, add new flow to this free entry if ip_frag_lookup() returns non-NULL if timeouted, reuse it for the received flow tbl->use_entries—; del_num++ ip_frag_process() rte_ip_frag_free_death_row() 주기적으로 호출해줘야 함"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2016-03-24T15:03:55+09:00"><meta property="article:modified_time" content="2018-04-01T02:38:51+00:00"><meta property="article:tag" content="DPDK"><meta property="article:tag" content="Reassembly"><meta property="article:tag" content="Ipv4"><meta name=twitter:card content="summary"><meta name=twitter:title content="DPDK IPv4 reassembly"><meta name=twitter:description content="rte_ipv4_frag_reassemble_packet()
ip_frag_find() 기존에 존재하는 flow면 해당 flow를 저장한 entry 정보를(ip_frag_pkt *pkg) 신규 flow인 경우 해당 신규 flow를 저장할 신규 혹은 재사용된 entry를 return함 추가할 수 있는 통계 신규 flow? 기존 flow에 정상 추가 기존 flow에 비정상 추가(기존 flow가 timeouted) 이도 저도 아닌 상황(할당 실패) LRU entry free tbl->max_entries tbl->use_entries return 기존 존재하는 flow, 신규 할당한 flow entry 혹은 NULL 만일 NULL을 return하면 현재 수신한 mbuf를 death row에 추가한다. 불쌍한… ip_frag_lookup() if matched entry is exist return flow entry return &amp;stale if time-outed entry is exist if new entry return NULL return free for new empty entry return &amp;stale if time-outed entry is exist ip_frag_key_cmp() return 0 if key matched if ip_frag_lookup() returns NULL if stale entry is not NULL, remove it with ip_frag_tbl_del() and save to free for reuse even if free is not NULL, check if tbl->use_entries does not exceed tbl->max_entries. If so, check if the LRU entry is timeouted, then free the LRU entry. Otherwise, fail to add new entry to the tbl tbl에서 할당하는 것고 max_entries, use_entries간의 차이점은?? If free is not NULL, add new flow to this free entry if ip_frag_lookup() returns non-NULL if timeouted, reuse it for the received flow tbl->use_entries—; del_num++ ip_frag_process() rte_ip_frag_free_death_row() 주기적으로 호출해줘야 함"><meta itemprop=name content="DPDK IPv4 reassembly"><meta itemprop=description content="rte_ipv4_frag_reassemble_packet()
ip_frag_find() 기존에 존재하는 flow면 해당 flow를 저장한 entry 정보를(ip_frag_pkt *pkg) 신규 flow인 경우 해당 신규 flow를 저장할 신규 혹은 재사용된 entry를 return함 추가할 수 있는 통계 신규 flow? 기존 flow에 정상 추가 기존 flow에 비정상 추가(기존 flow가 timeouted) 이도 저도 아닌 상황(할당 실패) LRU entry free tbl->max_entries tbl->use_entries return 기존 존재하는 flow, 신규 할당한 flow entry 혹은 NULL 만일 NULL을 return하면 현재 수신한 mbuf를 death row에 추가한다. 불쌍한… ip_frag_lookup() if matched entry is exist return flow entry return &amp;stale if time-outed entry is exist if new entry return NULL return free for new empty entry return &amp;stale if time-outed entry is exist ip_frag_key_cmp() return 0 if key matched if ip_frag_lookup() returns NULL if stale entry is not NULL, remove it with ip_frag_tbl_del() and save to free for reuse even if free is not NULL, check if tbl->use_entries does not exceed tbl->max_entries. If so, check if the LRU entry is timeouted, then free the LRU entry. Otherwise, fail to add new entry to the tbl tbl에서 할당하는 것고 max_entries, use_entries간의 차이점은?? If free is not NULL, add new flow to this free entry if ip_frag_lookup() returns non-NULL if timeouted, reuse it for the received flow tbl->use_entries—; del_num++ ip_frag_process() rte_ip_frag_free_death_row() 주기적으로 호출해줘야 함"><meta itemprop=datePublished content="2016-03-24T15:03:55+09:00"><meta itemprop=dateModified content="2018-04-01T02:38:51+00:00"><meta itemprop=wordCount content="202"><meta itemprop=keywords content="DPDK,Reassembly,Ipv4"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style></head><body><header><a href=/ class=title><h2>Keep calm and Write something</h2></a><nav><a href=/post/>Post</a>
<a href=/page/>Page</a>
<a href=/series/>Series</a>
<a href=/tags/>Tag</a>
<a href=/archive/>Archive</a>
<a href=/search/>Search</a></nav></header><main><content><p><code>rte_ipv4_frag_reassemble_packet()</code></p><ul><li><code>ip_frag_find()</code><ul><li>기존에 존재하는 flow면 해당 flow를 저장한 entry 정보를(<code>ip_frag_pkt *pkg</code>)</li><li>신규 flow인 경우 해당 신규 flow를 저장할 신규 혹은 재사용된 entry를 return함</li><li>추가할 수 있는 통계<ul><li>신규 flow?</li><li>기존 flow에 정상 추가</li><li>기존 flow에 비정상 추가(기존 flow가 timeouted)</li><li>이도 저도 아닌 상황(할당 실패)</li><li>LRU entry free</li><li><code>tbl->max_entries</code></li><li><code>tbl->use_entries</code></li></ul></li><li>return<ul><li>기존 존재하는 flow, 신규 할당한 flow entry 혹은 NULL</li><li>만일 NULL을 return하면 현재 수신한 mbuf를 death row에 추가한다. 불쌍한&mldr;</li></ul></li><li><code>ip_frag_lookup()</code><ul><li>if matched entry is exist<ul><li>return flow entry</li><li>return <code>&amp;stale</code> if time-outed entry is exist</li></ul></li><li>if new entry<ul><li>return NULL</li><li>return free for new empty entry</li><li>return <code>&amp;stale</code> if time-outed entry is exist</li></ul></li><li><code>ip_frag_key_cmp()</code> return 0 if key matched</li></ul></li><li>if <code>ip_frag_lookup()</code> returns NULL<ul><li>if stale entry is not NULL, remove it with <code>ip_frag_tbl_del()</code> and save to free for reuse</li><li>even if free is not NULL, check if <code>tbl->use_entries</code> does not exceed <code>tbl->max_entries</code>. If so, check if the LRU entry is timeouted, then free the LRU entry. Otherwise, fail to add new entry to the tbl</li><li>tbl에서 할당하는 것고 <code>max_entries</code>, <code>use_entries</code>간의 차이점은??</li><li>If free is not NULL, add new flow to this free entry</li></ul></li><li>if <code>ip_frag_lookup()</code> returns non-NULL<ul><li>if timeouted, reuse it for the received flow</li></ul></li><li><code>tbl->use_entries—; del_num++</code></li></ul></li><li><code>ip_frag_process()</code></li><li><code>rte_ip_frag_free_death_row()</code> 주기적으로 호출해줘야 함</li></ul></content><p><a href=https://cychong47.github.io/tags/dpdk/>#DPDK</a>
<a href=https://cychong47.github.io/tags/reassembly/>#Reassembly</a>
<a href=https://cychong47.github.io/tags/ipv4/>#Ipv4</a></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>