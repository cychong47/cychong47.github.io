<!doctype html><html lang=en-us><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>DPDK 2.2 crypto dev API | Keep calm and Write something</title><meta name=title content="DPDK 2.2 crypto dev API"><meta name=description content='pktmbuf_offload

pool은 rte_pktmbuf_offload_pool_create()를 사용하여 생성

l2fwd_mbuf_ol_pool = rte_pktmbuf_offload_pool_create(
            "mbuf_offload_pool", NB_MBUF, 128, 0, rte_socket_id());

할당은 rte_pktmbuf_offload_alloc()를 이용.

rte_pktmbuf_offload_alloc(l2fwd_mbuf_ol_pool, RTE_PKTMBUF_OL_CRYPTO);

mbuf 마다 하나씩 할당해서 crypto 연산에 사용
crypto 연산에 필요한 추가 옵션 등을 설정함.

/* Append space for digest to end of packet */
ol->op.crypto.digest.data = (uint8_t *)rte_pktmbuf_append(m,
		cparams->digest_length);
ol->op.crypto.digest.phys_addr = rte_pktmbuf_mtophys_offset(m,
		rte_pktmbuf_pkt_len(m) - cparams->digest_length);
ol->op.crypto.digest.length = cparams->digest_length;

ol->op.crypto.iv.data = cparams->iv_key.data;
ol->op.crypto.iv.phys_addr = cparams->iv_key.phys_addr;
ol->op.crypto.iv.length = cparams->iv_key.length;

ol->op.crypto.data.to_cipher.offset = ipdata_offset;
ol->op.crypto.data.to_cipher.length = data_len;

ol->op.crypto.data.to_hash.offset = ipdata_offset;
ol->op.crypto.data.to_hash.length = data_len;
l2fwd_simple_crypto_enqueue()

crypto operation에 맞게 data align에 맞게 padding
rte_crypto_op_attach_session()
ol->op에 crypto 연산에 필요한 정보를 설정

crypto 대상 위치, 길이 등
session 개념이 있는데 정확히 뭔지는 모르겠음…


rte_crypto_op_attach_session()

op->session = sess;
op->type = RTE_CRYPTO_OP_WITH_SESSION;

rte_pktmbuf_offload_attach()

l2fwd_crypto_enqueue()

l2fwd_crypto_send_burst()

rte_cryptodev_enqueue_burst()



struct rte_mbuf_offload
/**
 * Generic packet mbuf offload
 * This is used to specify a offload operation to be performed on a rte_mbuf.
 * Multiple offload operations can be chained to the same mbuf, but only a
 * single offload operation of a particular type can be in the chain
 */
struct rte_mbuf_offload {
        struct rte_mbuf_offload *next;  /**< next offload in chain */
        struct rte_mbuf *m;             /**< mbuf offload is attached to */
        struct rte_mempool *mp;         /**< mempool offload allocated from */

        enum rte_mbuf_ol_op_type type;  /**< offload type */
        union {
                struct rte_crypto_op crypto;    /**< Crypto operation */
        } op;
};
'><meta name=keywords content><meta property="og:url" content="https://cychong47.github.io/post/2016/dpdk-2-2-crypto-dev-api/"><meta property="og:site_name" content="Keep calm and Write something"><meta property="og:title" content="DPDK 2.2 crypto dev API"><meta property="og:description" content='pktmbuf_offload pool은 rte_pktmbuf_offload_pool_create()를 사용하여 생성 l2fwd_mbuf_ol_pool = rte_pktmbuf_offload_pool_create( "mbuf_offload_pool", NB_MBUF, 128, 0, rte_socket_id()); 할당은 rte_pktmbuf_offload_alloc()를 이용. rte_pktmbuf_offload_alloc(l2fwd_mbuf_ol_pool, RTE_PKTMBUF_OL_CRYPTO); mbuf 마다 하나씩 할당해서 crypto 연산에 사용 crypto 연산에 필요한 추가 옵션 등을 설정함. /* Append space for digest to end of packet */ ol->op.crypto.digest.data = (uint8_t *)rte_pktmbuf_append(m, cparams->digest_length); ol->op.crypto.digest.phys_addr = rte_pktmbuf_mtophys_offset(m, rte_pktmbuf_pkt_len(m) - cparams->digest_length); ol->op.crypto.digest.length = cparams->digest_length; ol->op.crypto.iv.data = cparams->iv_key.data; ol->op.crypto.iv.phys_addr = cparams->iv_key.phys_addr; ol->op.crypto.iv.length = cparams->iv_key.length; ol->op.crypto.data.to_cipher.offset = ipdata_offset; ol->op.crypto.data.to_cipher.length = data_len; ol->op.crypto.data.to_hash.offset = ipdata_offset; ol->op.crypto.data.to_hash.length = data_len; l2fwd_simple_crypto_enqueue() crypto operation에 맞게 data align에 맞게 padding rte_crypto_op_attach_session() ol->op에 crypto 연산에 필요한 정보를 설정 crypto 대상 위치, 길이 등 session 개념이 있는데 정확히 뭔지는 모르겠음… rte_crypto_op_attach_session() op->session = sess; op->type = RTE_CRYPTO_OP_WITH_SESSION; rte_pktmbuf_offload_attach() l2fwd_crypto_enqueue() l2fwd_crypto_send_burst() rte_cryptodev_enqueue_burst() struct rte_mbuf_offload /** * Generic packet mbuf offload * This is used to specify a offload operation to be performed on a rte_mbuf. * Multiple offload operations can be chained to the same mbuf, but only a * single offload operation of a particular type can be in the chain */ struct rte_mbuf_offload { struct rte_mbuf_offload *next; /**< next offload in chain */ struct rte_mbuf *m; /**< mbuf offload is attached to */ struct rte_mempool *mp; /**< mempool offload allocated from */ enum rte_mbuf_ol_op_type type; /**< offload type */ union { struct rte_crypto_op crypto; /**< Crypto operation */ } op; };'><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2016-01-24T15:08:11+09:00"><meta property="article:modified_time" content="2018-04-01T02:38:40+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="DPDK 2.2 crypto dev API"><meta name=twitter:description content='pktmbuf_offload pool은 rte_pktmbuf_offload_pool_create()를 사용하여 생성 l2fwd_mbuf_ol_pool = rte_pktmbuf_offload_pool_create( "mbuf_offload_pool", NB_MBUF, 128, 0, rte_socket_id()); 할당은 rte_pktmbuf_offload_alloc()를 이용. rte_pktmbuf_offload_alloc(l2fwd_mbuf_ol_pool, RTE_PKTMBUF_OL_CRYPTO); mbuf 마다 하나씩 할당해서 crypto 연산에 사용 crypto 연산에 필요한 추가 옵션 등을 설정함. /* Append space for digest to end of packet */ ol->op.crypto.digest.data = (uint8_t *)rte_pktmbuf_append(m, cparams->digest_length); ol->op.crypto.digest.phys_addr = rte_pktmbuf_mtophys_offset(m, rte_pktmbuf_pkt_len(m) - cparams->digest_length); ol->op.crypto.digest.length = cparams->digest_length; ol->op.crypto.iv.data = cparams->iv_key.data; ol->op.crypto.iv.phys_addr = cparams->iv_key.phys_addr; ol->op.crypto.iv.length = cparams->iv_key.length; ol->op.crypto.data.to_cipher.offset = ipdata_offset; ol->op.crypto.data.to_cipher.length = data_len; ol->op.crypto.data.to_hash.offset = ipdata_offset; ol->op.crypto.data.to_hash.length = data_len; l2fwd_simple_crypto_enqueue() crypto operation에 맞게 data align에 맞게 padding rte_crypto_op_attach_session() ol->op에 crypto 연산에 필요한 정보를 설정 crypto 대상 위치, 길이 등 session 개념이 있는데 정확히 뭔지는 모르겠음… rte_crypto_op_attach_session() op->session = sess; op->type = RTE_CRYPTO_OP_WITH_SESSION; rte_pktmbuf_offload_attach() l2fwd_crypto_enqueue() l2fwd_crypto_send_burst() rte_cryptodev_enqueue_burst() struct rte_mbuf_offload /** * Generic packet mbuf offload * This is used to specify a offload operation to be performed on a rte_mbuf. * Multiple offload operations can be chained to the same mbuf, but only a * single offload operation of a particular type can be in the chain */ struct rte_mbuf_offload { struct rte_mbuf_offload *next; /**< next offload in chain */ struct rte_mbuf *m; /**< mbuf offload is attached to */ struct rte_mempool *mp; /**< mempool offload allocated from */ enum rte_mbuf_ol_op_type type; /**< offload type */ union { struct rte_crypto_op crypto; /**< Crypto operation */ } op; };'><meta itemprop=name content="DPDK 2.2 crypto dev API"><meta itemprop=description content='pktmbuf_offload pool은 rte_pktmbuf_offload_pool_create()를 사용하여 생성 l2fwd_mbuf_ol_pool = rte_pktmbuf_offload_pool_create( "mbuf_offload_pool", NB_MBUF, 128, 0, rte_socket_id()); 할당은 rte_pktmbuf_offload_alloc()를 이용. rte_pktmbuf_offload_alloc(l2fwd_mbuf_ol_pool, RTE_PKTMBUF_OL_CRYPTO); mbuf 마다 하나씩 할당해서 crypto 연산에 사용 crypto 연산에 필요한 추가 옵션 등을 설정함. /* Append space for digest to end of packet */ ol->op.crypto.digest.data = (uint8_t *)rte_pktmbuf_append(m, cparams->digest_length); ol->op.crypto.digest.phys_addr = rte_pktmbuf_mtophys_offset(m, rte_pktmbuf_pkt_len(m) - cparams->digest_length); ol->op.crypto.digest.length = cparams->digest_length; ol->op.crypto.iv.data = cparams->iv_key.data; ol->op.crypto.iv.phys_addr = cparams->iv_key.phys_addr; ol->op.crypto.iv.length = cparams->iv_key.length; ol->op.crypto.data.to_cipher.offset = ipdata_offset; ol->op.crypto.data.to_cipher.length = data_len; ol->op.crypto.data.to_hash.offset = ipdata_offset; ol->op.crypto.data.to_hash.length = data_len; l2fwd_simple_crypto_enqueue() crypto operation에 맞게 data align에 맞게 padding rte_crypto_op_attach_session() ol->op에 crypto 연산에 필요한 정보를 설정 crypto 대상 위치, 길이 등 session 개념이 있는데 정확히 뭔지는 모르겠음… rte_crypto_op_attach_session() op->session = sess; op->type = RTE_CRYPTO_OP_WITH_SESSION; rte_pktmbuf_offload_attach() l2fwd_crypto_enqueue() l2fwd_crypto_send_burst() rte_cryptodev_enqueue_burst() struct rte_mbuf_offload /** * Generic packet mbuf offload * This is used to specify a offload operation to be performed on a rte_mbuf. * Multiple offload operations can be chained to the same mbuf, but only a * single offload operation of a particular type can be in the chain */ struct rte_mbuf_offload { struct rte_mbuf_offload *next; /**< next offload in chain */ struct rte_mbuf *m; /**< mbuf offload is attached to */ struct rte_mempool *mp; /**< mempool offload allocated from */ enum rte_mbuf_ol_op_type type; /**< offload type */ union { struct rte_crypto_op crypto; /**< Crypto operation */ } op; };'><meta itemprop=datePublished content="2016-01-24T15:08:11+09:00"><meta itemprop=dateModified content="2018-04-01T02:38:40+00:00"><meta itemprop=wordCount content="215"><meta itemprop=keywords content="TIL"><meta name=referrer content="no-referrer-when-downgrade"><style>:root{--width:720px;--font-main:Verdana, sans-serif;--font-secondary:Verdana, sans-serif;--font-scale:1em;--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}@media(prefers-color-scheme:dark){:root{--background-color:#fafafa;--heading-color:#222;--text-color:#444;--link-color:#3273dc;--visited-color:#8b6fcb;--blockquote-color:#222}}body{font-family:var(--font-secondary);font-size:var(--font-scale);margin:auto;padding:20px;max-width:var(--width);text-align:left;background-color:var(--background-color);word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:var(--text-color)}h1,h2,h3,h4,h5,h6{font-family:var(--font-main);color:var(--heading-color)}a{color:var(--link-color);cursor:pointer;text-decoration:none}a:hover{text-decoration:underline}nav a{margin-right:8px}strong,b{color:var(--heading-color)}button{margin:0;cursor:pointer}time{font-family:monospace;font-style:normal;font-size:15px}main{line-height:1.6}table{width:100%}hr{border:0;border-top:1px dashed}img{max-width:100%}code{font-family:monospace;padding:2px;border-radius:3px}blockquote{border-left:1px solid #999;color:var(--blockquote-color);padding-left:20px;font-style:italic}footer{padding:25px 0;text-align:center}.title:hover{text-decoration:none}.title h1{font-size:1.5em}.inline{width:auto!important}.highlight,.code{border-radius:3px;margin-block-start:1em;margin-block-end:1em;overflow-x:auto}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li{display:flex}ul.blog-posts li span{flex:0 0 130px}ul.blog-posts li a:visited{color:var(--visited-color)}</style></head><body><header><a href=/ class=title><h2>Keep calm and Write something</h2></a><nav><a href=/post/>Post</a>
<a href=/page/>Page</a>
<a href=/series/>Series</a>
<a href=/tags/>Tag</a>
<a href=/archive/>Archive</a>
<a href=/search/>Search</a></nav></header><main><content><h3 id=pktmbuf_offload>pktmbuf_offload</h3><ul><li>pool은 <code>rte_pktmbuf_offload_pool_create()</code>를 사용하여 생성</li></ul><pre tabindex=0><code>l2fwd_mbuf_ol_pool = rte_pktmbuf_offload_pool_create(
            &#34;mbuf_offload_pool&#34;, NB_MBUF, 128, 0, rte_socket_id());
</code></pre><ul><li>할당은 <code>rte_pktmbuf_offload_alloc()</code>를 이용.</li></ul><pre tabindex=0><code>rte_pktmbuf_offload_alloc(l2fwd_mbuf_ol_pool, RTE_PKTMBUF_OL_CRYPTO);
</code></pre><ul><li>mbuf 마다 하나씩 할당해서 crypto 연산에 사용</li><li>crypto 연산에 필요한 추가 옵션 등을 설정함.</li></ul><pre tabindex=0><code>/* Append space for digest to end of packet */
ol-&gt;op.crypto.digest.data = (uint8_t *)rte_pktmbuf_append(m,
		cparams-&gt;digest_length);
ol-&gt;op.crypto.digest.phys_addr = rte_pktmbuf_mtophys_offset(m,
		rte_pktmbuf_pkt_len(m) - cparams-&gt;digest_length);
ol-&gt;op.crypto.digest.length = cparams-&gt;digest_length;

ol-&gt;op.crypto.iv.data = cparams-&gt;iv_key.data;
ol-&gt;op.crypto.iv.phys_addr = cparams-&gt;iv_key.phys_addr;
ol-&gt;op.crypto.iv.length = cparams-&gt;iv_key.length;

ol-&gt;op.crypto.data.to_cipher.offset = ipdata_offset;
ol-&gt;op.crypto.data.to_cipher.length = data_len;

ol-&gt;op.crypto.data.to_hash.offset = ipdata_offset;
ol-&gt;op.crypto.data.to_hash.length = data_len;
</code></pre><h3 id=l2fwd_simple_crypto_enqueue><code>l2fwd_simple_crypto_enqueue()</code></h3><ul><li>crypto operation에 맞게 data align에 맞게 padding</li><li><code>rte_crypto_op_attach_session()</code></li><li><code>ol->op</code>에 crypto 연산에 필요한 정보를 설정<ul><li>crypto 대상 위치, 길이 등</li><li>session 개념이 있는데 정확히 뭔지는 모르겠음…</li></ul></li><li><code>rte_crypto_op_attach_session()</code></li></ul><pre tabindex=0><code>op-&gt;session = sess;
op-&gt;type = RTE_CRYPTO_OP_WITH_SESSION;
</code></pre><ul><li><code>rte_pktmbuf_offload_attach()</code></li></ul><h5 id=l2fwd_crypto_enqueue><code>l2fwd_crypto_enqueue()</code></h5><ul><li><code>l2fwd_crypto_send_burst()</code><ul><li><code>rte_cryptodev_enqueue_burst()</code></li></ul></li></ul><h3 id=struct-rte_mbuf_offload><code>struct rte_mbuf_offload</code></h3><pre tabindex=0><code>/**
 * Generic packet mbuf offload
 * This is used to specify a offload operation to be performed on a rte_mbuf.
 * Multiple offload operations can be chained to the same mbuf, but only a
 * single offload operation of a particular type can be in the chain
 */
struct rte_mbuf_offload {
        struct rte_mbuf_offload *next;  /**&lt; next offload in chain */
        struct rte_mbuf *m;             /**&lt; mbuf offload is attached to */
        struct rte_mempool *mp;         /**&lt; mempool offload allocated from */

        enum rte_mbuf_ol_op_type type;  /**&lt; offload type */
        union {
                struct rte_crypto_op crypto;    /**&lt; Crypto operation */
        } op;
};
</code></pre></content><p></p></main><footer>Made with <a href=https://github.com/janraasch/hugo-bearblog/>Hugo ʕ•ᴥ•ʔ Bear</a></footer></body></html>